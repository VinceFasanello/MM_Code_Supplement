---
title: "Analyze.rmd"
output:
  html_document:
    df_print: paged
---
***
#### Description:  
|   This script takes inputs in the form of counts matrices and dataframes 
|   formatted for analysis by the CountstoAnalysis scripts for the 001 and
|   002 datasets (with all calculations and formatting already completed) --
|   See Inputs for all inputs. The script then conducts all summary 
|   calculations, statistical tests, and produces all visuals and output tables
|   found in the main text and supplement (unless otherwise noted below -- see 
|   Outputs). Code blocks appear in more-or-less the same order that data are 
|   presented in the text; brief descriptions head each box and more detailed 
|   code can be found in-line. This script outputs a set of figures and tables 
|   that are included, some with modification and stylization, in the main text 
|   and supplement. 

***
#### Inputs:  
1.    poc1.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay single-barcode controls.
2.    poc2.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay dual-barcode controls.
3.    poc92.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay fitness assay samples.
4.    001_counts.expected.Rdata --  FastqtoCounts formatted matrix for POC fitness assay library expected (by design) counts.
5.    001_counts.unexpected.Rdata --  FastqtoCounts formatted matrix for POC fitness assay library unexpected (barcode cross-contamination) counts.
6.    002_CC_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- consensus matrix constructed from two sequenced libraries.
7.    002_CC_counts.unexpected.Rdata --  FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- consensus matrix from two sequenced libraries.
8.    002_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- original sequenced library.
9.    002_counts.unexpected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- original sequenced library.
10.   002_Reruns_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- resequenced samples library.
11.   002_Reruns_counts.unexpected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- resequenced samples library.
12.   myfa.Rdata -- CountstoAnalysis formatted dataframe for 250-generation experimental evolution project fitness assays.
13.   myevo.Rdata -- CountstoAnalysis formatted dataframe for 250-generation experimental evolution project longitudinal samples.


***
#### Outputs:  
Main Figures:
1.  000_Figure_2.pdf 
2.  000_Figure_3.pdf
3.  000_Figure_4.pdf 
4.  000_Figure_5.pdf

Additional Files:
1.  000_Additional_File_4.html
2.  000_Additional_File_5.html
3.  000_Additional_File_6.html
4.  000_Additional_File_7.pdf
5.  000_Additional_File_8.pdf
6.  000_Additional_File_9.html
7.  000_Additional_File_10.html
8.  000_Additional_File_11.html
9.  000_Additional_File_12.html
10.  000_Additional_File_13.html
11.  000_Additional_File_14.html
12.  000_Additional_File_15.pdf
13.  000_Additional_File_16.html
14.  000_Additional_File_17.pdf
15.  000_Additional_File_18.html
16.  000_Additional_File_19.pdf
17.  000_Additional_File_20.html
18.  000_Additional_File_21.pdf
19.  000_Additional_File_22.html
20.  000_Additional_File_23.pdf
21.  000_Additional_File_24.html
22.  000_Additional_File_25.pdf
23.  000_Additional_File_26.html
24.  000_Additional_File_27.pdf


* Figure_1, is not output by this script; it is manually created in excel 

* Table_1 is not created directly from this script, but is built from outputs associated with Additional Files 14:27.

* Additional Files 1, 2, and 3 are created by hand in excel and are not created by this script

* Additional_File_4 is output with raw p-values, but values are converted to fdr for publication and presented in an xlsx format document. Additional_File_12 is output with raw 2-sided test p-values, but values are converted to 1-sided (higher) and fdr for publication and presented in an xlsx format document. 


***
### Begin Code Blocks:

Prepare the workspace: clean, set options, load packages, load and final formatting on inputs.
```{r, warning = FALSE, message=FALSE}
rm(list = ls()) # clear workspace
knitr::opts_chunk$set(tidy = TRUE, collapse = TRUE) # set global knitr options.
# load required packages
require(ggplot2); # used for plotting #check#
require(pwr); # used for power analysis
require(lme4); # used for mixed effects models #check#
require(lmerTest); # used to interpret mixed effects models #check#
require(sjPlot); # used to output tables #check#
require(weights); # used for weighted t.test #check#
require(plyr); # used for dataframe manipulation #check#
require(gridExtra) # used for multipanel plotting #check#
require(MuMIn) # model seleciton and multimodel inference

options(scipen = 999) # turn off scientific notation
```
<br/><br/>


Load the required datasets and Conduct any last minute calculations
```{r, warning = FALSE, message=FALSE}
dir_in_pocpro <- "2_CountstoAnalysis/001_Prepare_Datasets" # input directory for Proof of concept processed dataframes
setwd("..")
setwd(dir_in_pocpro) # set to above directory path
load(file = "poc1.Rdata") # load the 1bc control processed dataframe
load(file = "poc2.Rdata") # load the 2 bc control processed dataframe
load(file = "poc92.Rdata") # load the 92 bc proof of concept fitness assays processed dataframe

dir_in_pocraw <- "001_Raw_Data_Metadata"  # input directory for Proof of concept raw dataframes
setwd("..")
setwd(dir_in_pocraw) # set to above directory path
load(file = "001_counts.expected.Rdata"); poc.ce <- (counts.expected + 1)[c(1:92),]; rm(counts.expected) # expected counts
load(file = "001_counts.unexpected.Rdata"); poc.cc <- (counts.unexpected + 1)[c(1:92),]; rm(counts.unexpected) # cross contamination counts. 

dir_in_faevoraw <- "002_Raw_Data_Metadata" # input directory for FA and Evo raw dataframes
setwd("..")
setwd(dir_in_faevoraw) # set to above directory path
load(file = "002_CC_counts.expected.Rdata"); faevo.ce <- (ects + 0); rm(ects) # expected counts {combined}
load(file = "002_CC_counts.unexpected.Rdata"); faevo.cc <- (ccts + 0); rm(ccts) # cross contamination counts.{combined}
load(file = "002_counts.expected.Rdata"); faevo.1.ce <- (counts.expected + 1)[c(1:78),]; rm(counts.expected) # expected counts {first run samples}
load(file = "002_counts.unexpected.Rdata"); faevo.1.cc <- (counts.unexpected + 1)[c(1:78),]; rm(counts.unexpected) # cross contamination counts. {first run samples}
load(file = "002_Reruns_counts.expected.Rdata"); faevo.2.ce <- (counts.expected + 1)[c(1:78),]; rm(counts.expected) # expected counts {rerun samples}
load(file = "002_Reruns_counts.unexpected.Rdata"); faevo.2.cc <- (counts.unexpected + 1)[c(1:78),]; rm(counts.unexpected) # cross contamination counts. {rerun samples}

dir_in_faevopro <- "002_Prepare_Datasets" # input directory for FA and Evo processed dataframes
setwd("..")
setwd(dir_in_faevopro) # set to above directory path
load(file = "myfa.Rdata") # fitness assay
load(file = "myevo.Rdata") # evolution
rm(dir_in_faevopro, dir_in_faevoraw, dir_in_pocpro, dir_in_pocraw)
```
<br/><br/>



Create helper functions for linear model residual plotting and data transformation.
```{r, warning = FALSE, message=FALSE}
# expand_residuals creates a modified histogram of residuals. Each entry in the model output is plotted a number of times equal to its reads.
expand_residuals <- function(model, reads){
  myfr <- NA
  for(i in 1:length(residuals(model))){
    times <- (((reads[i] - min(reads, na.rm = T))/(max(reads) - min(reads)))*1000) + 1 
    myfr <- c(myfr, rep(residuals(model)[i], times = times))
  }
  return(myfr)
}

# log transformation for modeling. 
log_transform <- function(myvar){
  myvar <- log(((myvar - min(myvar))/(max(myvar) - min(myvar))) + 1) 
  return(myvar)
}

# get legend function found on stack exchange ----------------------------------
#  Source: https://stackoverflow.com/questions/12041042/how-to-plot-just-the-legends-in-ggplot2
#  scrapes figure legend for later plotting in multipannel plot
get_legend<-function(myggplot){
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}
```
<br/><br/>



Set color palette options for all plots
```{r}
setpalette <- RColorBrewer::brewer.pal(6, "Dark2") # current preferred palette
#setpalette <- c("#993404","#d95f0e","#fe9929","#41b6c4","#2c7fb8","#253494") # option 2
#setpalette <- c("#8c510a","#d8b365","#f6e8c3", "#c7eae5","#5ab4ac","#01665e") # option 3
```
<br/><br/>



Analysis: Assess POC fitness assay barcode fitness equivalence.
```{r}
my <- poc92[order(poc92$bcid),]

# model & diagnostic plots ----------------------------------------------------
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected~ my$bcid + 0, weights = my$r); summary(mymod)
hist(residuals(mymod), breaks = 50) # residuals look good, check the other diagnostic plots too...
hist(expand_residuals(mymod, my$r), breaks = 50) # this more accurately represents the distribution of residuals in the model output.
plot(mymod) # view the diagnostic plots
paste0("Number of BCs with fitness different than pop mean = ",
       sum(p.adjust(coef(summary(mymod))[,4], method = "fdr") < 0.05)) # number of barcodes with fit different than pop weighted mean. 
paste0("RsMSE = ",
       sqrt(mean(residuals(mymod)^2))) # report rmse (requires unscalled lm model)
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T,  wrap.labels = 100, file = "000_Additional_File_4.html")
# -----------------------------------------------------------------------------

# create temporary plotting dataframe -----------------------------------------
myres <- as.data.frame(coef(summary(mymod)), stringsAsFactors = F) # create a myres dataframe to aid in plotting. 
myres$p.adjust <- p.adjust(myres$`Pr(>|t|)`, method = "fdr") # adjusted p-values
myres$bcid <-  gsub("^.*?d","",rownames(myres)) # fix barcode id names
myres$mrw <- ddply(my, ~bcid, function(my) weighted.mean(my$rw, my$r))[,2] # weighted mean for fitness
myres$rmrw <- ddply(my, ~bcid, function(my) mean(my$r))[,2] # mean for weights
myres$mcmrw <- myres$mrw - weighted.mean(myres$mrw, myres$rmrw) # mean corrected fitness
myres$color <- "fdr > 0.05"; myres$color[myres$p.adjust <= 0.05] <- "fdr <= 0.05" # set plotting colors
myres$color <- as.factor(myres$color); myres$color <- relevel(myres$color, "fdr > 0.05")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myres$mcmrw
myr <- myres$rmrw
myc <- myres$color
mybinwidth <- 0.0025

mytitle <- NULL
myylab <- "Count"
myxlab <- "Fitness difference from population mean"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 3.345 
mywidth <- 3.345

p <- ggplot(myres, aes(x=myx, color = myc, fill = myc)) + 
  geom_histogram(alpha = myfillapha, position = "identity", binwidth = mybinwidth) +
  geom_rug(alpha = myptalpha)+
  #xlim(c(-0.06, 0.06)) +
  ylim(c(NA,15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = myhighlight) +
  scale_color_manual(values =mypalette, guide = FALSE) + 
  scale_fill_manual(values =mypalette) +
  theme_classic() +
  theme(legend.position= c(0.8,0.8)) +
  labs(fill = "Significance") +
  ggtitle(mytitle)+ ylab(myylab)+ xlab(myxlab)+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  theme(legend.title = element_text(size = mytextsize, face = "bold"))+
  theme(legend.text = element_text(size = mytextsize))+
  scale_x_continuous(breaks = seq(-0.06,0.06,by=0.01), 
                     labels = c("-0.06", "", "-0.04", "", "-0.02", "", "0", "", "0.02", "", "0.04", "", "0.06"),
                     limits = c(-0.06, 0.06))
p
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_2.pdf", width = mywidth, height = myheight); p; dev.off() # one column wide, equal height

# -----------------------------------------------------------------------------
rm(p, myres, mymod, my, mybinwidth, myc, myfillapha, myheight, myhighlight, mylinealpha, myptalpha, myr, mytextsize, mytitle, mywidth, myx, myxlab, myylab, mypalette)
```
<br/><br/>



Analysis: Calculate sequenced library reads summary values
```{r}
paste0("matching counts (match f and r primer barcode, and moby bc): ", sum(c(poc.ce, poc.cc, faevo.1.ce, faevo.1.cc, faevo.2.ce, faevo.2.cc), na.rm = T)) # match forward primer, reverse primer, and yeast strain BCs
paste0("analysis counts: ", sum(c(poc.ce, poc.cc, faevo.ce, faevo.cc), na.rm = T)) # expected and cc counts in the analysis data
paste0("expected analysis counts: ", sum(c(poc.ce,faevo.ce), na.rm = T)) # expected counts in the analysis data
paste0("median counts per barcode: ",median(c(poc.ce, faevo.ce),  na.rm = T)) # median number of counts per barcode in the expected counts dataset.


paste0("median counts per barcode: ",median(c(faevo.ce),  na.rm = T)) # median number of counts per barcode in the expected counts dataset.
paste0("median counts per barcode: ",median(c(poc.ce),  na.rm = T)) # median number of counts per barcode in the expected counts dataset.
my <- c(faevo.ce, poc.ce)
median(my, na.rm = T)
```
<br/><br/>



Analysis: Assess POC library barcode cross-contamination rate.
```{r}
# calculations ----------------------------------------------------------------
cc = (((colSums(poc.cc, na.rm = T)) / (colSums(poc.ce, na.rm = T) + colSums(poc.cc, na.rm = T))) / colSums(!is.na(poc.cc)))*100 # cc rate per exp
cc[is.nan(cc)] <- NA # NA nans
myt <- as.data.frame(cc) # convert to dataframe
myt$tc <- (colSums(poc.ce, na.rm = T) + colSums(poc.cc, na.rm = T)) # total counts to use as weight in weighted mean
cc001 <- weighted.mean(myt$cc, myt$tc, na.rm = T) # save weighted mean cc (by expected reads) for grand cc rate. 
r001 <- mean(myt$tc) # save mean for below calculation of grand cc rate. 
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myt$cc
myr <- myt$tc
myc <- setpalette[1]

mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Mean Barcode Contamination Rate (Percent Total Counts)"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mytextsize <- 8
myheight <- 3.5
mywidth <- 7

p_a <- ggplot(myt, aes(x=myx)) +
  geom_histogram(alpha = myfillapha ,color = myc, fill = myc,  binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx, myr, na.rm = T), linetype = "dashed", color = myhighlight) +
  geom_rug(color = myc, alpha = myptalpha)+
  xlim(NA, 1.0) +
  theme_classic() +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab) +
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  annotate("text", x = 1, y = 47, label = "A", size = 10)
p_a
# -----------------------------------------------------------------------------
rm(cc, myt) # remove the temporary variable
```
<br/><br/>



Analysis: Assess 250-generation experiment consensus library barcode cross-contamination rate.
```{r}
# Calculations ----------------------------------------------------------------
cc = ((colSums(faevo.cc, na.rm = T)) / (colSums(faevo.ce, na.rm = T) + colSums(faevo.cc, na.rm = T))) / colSums(!is.na(faevo.cc))*100 # cc rate per exp
cc[is.nan(cc)] <- NA # NA nans
myt <- as.data.frame(cc) # convert to dataframe
myt$tc <- (colSums(faevo.ce, na.rm = T) + colSums(faevo.cc, na.rm = T)) # total counts to use as weight in weighted mean
cc002 <-  weighted.mean(myt$cc, myt$tc, na.rm = T)  # save weighted mean cc (by expected reads) for grand cc rate. 
r002 <- mean(myt$tc) # save mean for below calculation of grand cc rate. 
 
# overall cc rate
paste0("mean cross contam as % total counts = ", weighted.mean(c(cc001, cc002), c(r001, r002)), " %") # weighted mean contam weighted.mean(c(contam rate poc, contam rate faevo), c(total counts poc, total counts faevo))
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx2 <- myt$cc
myr <- myt$tc
myc <- setpalette[1]

mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Mean Barcode Contamination Rate (Percent Total Counts)"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mytextsize <- 8
myheight <- 7
mywidth <- 7

p_b <- ggplot(myt, aes(x=myx2)) +
  geom_histogram(alpha = myfillapha ,color = myc, fill = myc,  binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx2, myr, na.rm = T), linetype = "dashed", color = myhighlight) +
  geom_rug(color = myc, alpha = myptalpha)+
  xlim(NA, 1.0) +
  theme_classic() +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  annotate("text", x = 1, y = 50, label = "B", size = 10)
p_b
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
grid.arrange(p_a, p_b, nrow = 2)
pdf(file = "000_Additional_File_7.pdf", width = mywidth, height = myheight); grid.arrange(p_a, p_b, nrow = 2); dev.off() # 2columns wide, half as tall

# -----------------------------------------------------------------------------
rm(cc, myt, p_a, p_b, cc001, cc002, r001, r002, myx2, mybinwidth, myc, myfillapha, myheight, myhighlight, mylinealpha, myptalpha, myr, mytextsize, mytitle, mywidth, myx, myxlab, myylab) # remove the temporary variable
```
<br/><br/>



Analysis: Assess change in barcode cross-contamination rate for samples from the 250-generation experiment that were resequenced.
```{r}
# Calculations & models -------------------------------------------------------
faevo.1.ce <- faevo.1.ce[,(colnames(faevo.1.ce) %in% colnames(faevo.2.ce))] # subset the run 1 data to only include those columns in the rerun dataset..expected counts..
faevo.1.cc <- faevo.1.cc[,(colnames(faevo.1.cc) %in% colnames(faevo.2.cc))] # cross contamination counts
faevo.1.ce <- faevo.1.ce[,colnames(faevo.1.ce)]; faevo.1.cc <- faevo.1.cc[,colnames(faevo.1.ce)] # reorder the run 1 data by column name
faevo.2.ce <- faevo.2.ce[,colnames(faevo.1.ce)]; faevo.2.cc <- faevo.2.cc[,colnames(faevo.1.ce)] # reorder the run 2 data by run 1 column name (for paired t test below)
myt1 <- ((colSums(faevo.1.cc, na.rm = T)) / (colSums(faevo.1.ce, na.rm = T) + colSums(faevo.1.cc, na.rm = T))) / colSums(!is.na(faevo.1.cc)) # cross contam run 1 
myt2 <- ((colSums(faevo.2.cc, na.rm = T)) / (colSums(faevo.2.ce, na.rm = T) + colSums(faevo.2.cc, na.rm = T))) / colSums(!is.na(faevo.2.cc)) # cross contam run 2
myt1r <- (colSums(faevo.1.ce, na.rm = T) +  colSums(faevo.1.cc, na.rm = T)) # reads run 1
myt2r  <- (colSums(faevo.2.ce, na.rm = T) +  colSums(faevo.2.cc, na.rm = T)) # reads run 2

myt <- myt1 - myt2 # calculatation for weighted t.test below (contam run 1 - contam run 2)
mytr <- 2/ ((1/myt1r) + (1/myt2r)) # reads for calculation below (harmonic mean of reads for run 1 and run 2)
mymod2 <- wtd.t.test(x = myt, y = 0, weight = mytr, alternative = "greater", mean1 = T) # t.test, paired, 1 sided (greater), weighted
# -----------------------------------------------------------------------------

# create temporary plotting dataframe -----------------------------------------
myt1 <- as.data.frame(cbind(myt1, myt1r)); colnames(myt1) <- c("cc", "r"); myt1$seq.run <- 1 # run 1 df
myt2 <- as.data.frame(cbind(myt2, myt2r)); colnames(myt2) <- c("cc", "r"); myt2$seq.run <- 2 # run 2 df
myt <- rbind(myt1, myt2); myt$seq.run <- as.factor(myt$seq.run) # combine
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myt$seq.run
myy <- myt$cc
myr <- myt$r

myx1 <- myt1$cc
myr1 <- myt1$r

myx2 <- myt2$cc
myr2 <- myt2$r

mytitle <-NULL
myylab <- "Mean Barcode Contamination Rate (% Total Counts)"
myxlab <- "Sequenced Libary Run Number"

myoutline <-  "grey50"
myfill <-  "grey90"
myhighlight <- "grey50"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 7
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(myt, aes(x=myx, y=myy, weight = myr, color = myx)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_segment(x=0.75, xend=1.25, y = weighted.mean(myx1, myr1),  yend = weighted.mean(myx1, myr1), color = myhighlight) +
  geom_segment(x=1.75, xend=2.25, y = weighted.mean(myx2, myr2),  yend = weighted.mean(myx2, myr2), color = myhighlight) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_rug(sides="l", alpha = myptalpha)+
  scale_color_manual(values = mypalette)+
  geom_hline(yintercept = 0, lty = "dotted") + 
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab) +
  scale_x_discrete(breaks=c("1","2"), labels=c("Library 1", "Library 2"))+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_8.pdf", width = mywidth, height = myheight); p; dev.off()  # 7by7

# -----------------------------------------------------------------------------
rm(faevo.1.ce, faevo.1.cc, faevo.2.ce, faevo.2.cc, myt1, myt1r, myt2, myt2r, myt, mytr, p) # clean up this section. 
rm(faevo.cc, faevo.ce, poc.cc, poc.ce) # clean up for next major set of analyses (remove the counts datasets to keep our global environment clean)
rm(myfill, myfillapha, myheight, myhighlight, mylinealpha, myoutline, mypalette, myptalpha, myptsize, myr, myr1, myr2, mytextsize, mytitle, mywidth, myx, myx1, myx2, myxlab, myy, myylab) # remove plotting params
```
<br/><br/>


Analysis: Assess fitness change in 250-generations of experimental evolution for barcodes in the 250-generation experiment. 
```{r}
my <- myfa[order(myfa$bctID),]
# model & diagnostic plots ----------------------------------------------------
mymod <- lm(deltafit ~ bctID + 0, weights = rdeltafit, data = my);summary(mymod)
hist(residuals(mymod), breaks = 100) # tails do look a little heavy
hist(expand_residuals(mymod, my$rdeltafit), breaks = 100) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # model fit (multi) -- looks pretty good. 
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_12.html") # table does not have corrected p-values. 
# -----------------------------------------------------------------------------

# create results dataframe ----------------------------------------------------
myres <- as.data.frame(coef(summary(mymod)), stringsAsFactors = F)
myres$p1s_l <- pt(coef(summary(mymod))[, 3], mymod$df, lower = T) # one-sided test p-values for lower
myres$p1s_h <- pt(coef(summary(mymod))[, 3], mymod$df, lower = F) # one-sided test p-values for higher
myres$p1s_l.adj <- p.adjust(myres$p1s_l, method = "fdr") # fdr adjusted p value (for 1-sided lower)
myres$p1s_h.adj <- p.adjust(myres$p1s_h, method = "fdr") # fdr adjusted p value (for 1-sided higher)
myres$bcid <-  gsub("^.*?D","",rownames(myres)) # fix barcode id names
myres$m_deltafit <- ddply(my, ~bctID, function(my) weighted.mean(my$deltafit, my$rdeltafit))[,2]
myres$m_rdeltafit <- ddply(my, ~bctID, function(my) mean(my$rdeltafit))[,2]
myres$mcm_deltafit <- myres$m_deltafit - weighted.mean(myres$m_deltafit, myres$m_rdeltafit)
myres$se_deltafit <- ddply(my, ~bctID, function(my) sjstats::se(my$deltafit))[,2]
myres$color <- "fdr > 0.01"; myres$color[myres$p1s_h.adj <= 0.01] <- "fdr <= 0.01"
myres$color <- as.factor(myres$color); myres$color <- relevel(myres$color, "fdr > 0.01")
myres$treatment <- gsub('0025d', '0025', gsub('001d', '001', gsub('.{4}$', '', myres$bcid))) # strip bc id from treatment label, store in myres
# -----------------------------------------------------------------------------

# review results --------------------------------------------------------------
paste0("weighted mean fitness increase for increasers = ",weighted.mean(myres$m_deltafit[myres$p1s_h.adj <= 0.01], myres$m_rdeltafit[myres$p1s_h.adj <= 0.01])) # weighted mean fit inc of sig increasers only
paste0("minimum fitness increase for increasers = ", min(myres$m_deltafit[myres$p1s_h.adj <= 0.01])) # minimum significant increase of 2.4%
paste0("maximum fitness increase for increasers = ", max(myres$m_deltafit[myres$p1s_h.adj <= 0.01]))# maximum significant increase of 23.5%

# all treatments together
paste0("Number of barcodes with significant decreases in fitness = ", nrow(myres[myres$p1s_l.adj <= 0.01, ]))  # check for significant fitness decrease: # find none
paste0("Number of barcodes with significant increases in fitness = ", nrow(myres[myres$p1s_h.adj <= 0.01, ]))  # check for significant fitness increase: # find 35 rows. (35 increasers out of 152)
paste0("Proportion of barcodes with significant increases in fitness = ",nrow(myres[myres$p1s_h.adj <= 0.01, ])/nrow(myres)) # prop increasers  # 0.23

# CM diploid 1:1000
paste0("CM diploid 1:1000:")
myrest <- myres[myres$treatment == "CMdiploid0.001",]; paste0("n barcodes in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM haploid 1:1000
paste0("CM haploid 1:1000:")
myrest <- myres[myres$treatment == "CMhaploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM+salt diploid 1:1000
paste0("CM+salt diploid 1:1000:")
myrest <- myres[myres$treatment == "CM+Saltdiploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM+ethanol diploid 1:1000
paste0("CM+ethanol diploid 1:1000:")
myrest <- myres[myres$treatment == "CM+Ethanoldiploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM diploid 1:250
paste0("CM diploid 1:250:")
myrest <- myres[myres$treatment == "CMdiploid0.004",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM diploid 1:4000
paste0("CM diploid 1:4000:")
myrest <- myres[myres$treatment == "CMdiploid0.00025",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
# Plot ONLY data with se_deltafit < 0.029 for clarity -- This removes high SE points that have a large mean fitness increase, but have SE such that this fit increase is non-significant.
myx <- myres[myres$se_deltafit < 0.029,]$m_deltafit
myr <- myres[myres$se_deltafit < 0.029,]$m_rdeltafit
myc <- myres[myres$se_deltafit < 0.029,]$color
mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Fitness change"

myhighlight <- "grey50"
myhighlight1 <- "black"
myhighlight2 <- setpalette[1]
myhighlight3 <- setpalette[2]
myfillapha <- 0.25
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 3.345
mywidth <- 3.345

p <- ggplot(myres[myres$se_deltafit < 0.029,], aes(x=myx, color = myc, fill = myc)) + 
  geom_histogram(alpha = myfillapha, position = "identity", binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx, myr), linetype = "dashed", color = myhighlight) +
  geom_vline(xintercept = weighted.mean(myx[myc == "fdr > 0.01"], myr[myc == "fdr > 0.01"]), linetype = "dashed", color = myhighlight2) +
  geom_vline(xintercept = weighted.mean(myx[myc == "fdr <= 0.01"], myr[myc== "fdr <= 0.01"]), linetype = "dashed", color = myhighlight3) +
  geom_rug(alpha = myptalpha)+
  scale_color_manual(values =mypalette, guide = FALSE) + 
  scale_fill_manual(values =mypalette) +
  theme_classic() +
  theme(legend.position= c(0.8,0.8)) +
  labs(fill = "Significance") +
  ggtitle(mytitle)+ ylab(myylab)+ xlab(myxlab) +
  geom_hline(yintercept=0.01, colour="white", size=1.01)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  theme(legend.title = element_text(size = mytextsize, face = "bold"))+
  theme(legend.text = element_text(size = mytextsize))+
  scale_x_continuous(breaks = seq(-0.1,0.25,by=0.05),
                     labels = c("-0.1", "-0.05", "0", "0.05", "0.1", "0.15", "0.2", "0.25"),
                     limits = c(-0.05, 0.25))+
  scale_y_continuous(breaks = seq(0,25,by=5),
                     limits = c(0,25))
p
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_4.pdf", width = mywidth, height = myheight); p; dev.off() # 7by7
# -----------------------------------------------------------------------------
rm(my, mymod, mymod2, myres, myrest, p)
rm(mybinwidth, myc, myfillapha, myheight, myhighlight, myhighlight1, myhighlight2, myhighlight3, mylinealpha, mypalette, myptalpha, myr, mytextsize, mytitle, mywidth, myx, myxlab, myylab)
```
<br/><br/>


Analysis: Characterization of error and contribution of covariates to SE deltafitness.
1: Build the dataframe to test SE delatfitness
```{R}
my <- myfa # get a copy of the main data to work on. 
# split by replicate and bind to form a wide frame.
my1 <- my[my$rep == 1,] # r1
my2 <- my[my$rep == 2,]; colnames(my2) <- paste0(colnames(my2), "_2") # r2
my3 <- my[my$rep == 3,]; colnames(my3) <- paste0(colnames(my3), "_3") # r3
my4 <- my[my$rep == 4,]; colnames(my4) <- paste0(colnames(my4), "_4") # r4
# sum(my1$bc1 != my2$bc1_2) # sort order matches.
my <- cbind(my1, my2, my3, my4) # bind

my$sedeltafit <- apply(cbind(my$deltafit, my$deltafit_2, my$deltafit_3, my$deltafit_4), 1, sjstats::se) # calculate SE deltafit among replicates
  
my$medcount <- apply(cbind(my$bc1cts_i_0r1,my$bc1cts_i_0r2,my$bc1cts_i_0r3,my$bc1cts_i_0r4,
                  my$bc1cts_f_0r1, my$bc1cts_f_0r2, my$bc1cts_f_0r3, my$bc1cts_f_0r4,
                  my$bc1cts_i, my$bc1cts_i_2, my$bc1cts_i_3, my$bc1cts_i_4,
                  my$bc1cts_f, my$bc1cts_f_2, my$bc1cts_f_3, my$bc1cts_f_4),
                  1, median, na.rm = T) # calculate median counts for each SE deltafit entry.

# Calculate BC proportions for next step @ all timepoints for all replicates.
my$prop_i_0r1 <- my$bc1cts_i_0r1 / (my$bc1cts_i_0r1 + my$bc2cts_i_0r1)
my$prop_i_0r2 <- my$bc1cts_i_0r2 / (my$bc1cts_i_0r2 + my$bc2cts_i_0r2)
my$prop_i_0r3 <- my$bc1cts_i_0r3 / (my$bc1cts_i_0r3 + my$bc2cts_i_0r3)
my$prop_i_0r4 <- my$bc1cts_i_0r4 / (my$bc1cts_i_0r4 + my$bc2cts_i_0r4)

my$prop_f_0r1 <- my$bc1cts_f_0r1 / (my$bc1cts_f_0r1 + my$bc2cts_f_0r1)
my$prop_f_0r2 <- my$bc1cts_f_0r2 / (my$bc1cts_f_0r2 + my$bc2cts_f_0r2)
my$prop_f_0r3 <- my$bc1cts_f_0r3 / (my$bc1cts_f_0r3 + my$bc2cts_f_0r3)
my$prop_f_0r4 <- my$bc1cts_f_0r4 / (my$bc1cts_f_0r4 + my$bc2cts_f_0r4)

my$prop_i_250r1 <- my$bc1cts_i / (my$bc1cts_i + my$bc2cts_i)
my$prop_i_250r2 <- my$bc1cts_i_2 / (my$bc1cts_i_2 + my$bc2cts_i_2)
my$prop_i_250r3 <- my$bc1cts_i_3 / (my$bc1cts_i_3 + my$bc2cts_i_3)
my$prop_i_250r4 <- my$bc1cts_i_4 / (my$bc1cts_i_4 + my$bc2cts_i_4)

my$prop_f_250r1 <- my$bc1cts_f / (my$bc1cts_f + my$bc2cts_f)
my$prop_f_250r2 <- my$bc1cts_f_2 / (my$bc1cts_f_2 + my$bc2cts_f_2)
my$prop_f_250r3 <- my$bc1cts_f_3 / (my$bc1cts_f_3 + my$bc2cts_f_3)
my$prop_f_250r4 <- my$bc1cts_f_4 / (my$bc1cts_f_4 + my$bc2cts_f_4)


my$medprop <- apply(cbind(my$prop_i_0r1,my$prop_i_0r2,my$prop_i_0r3,my$prop_i_0r4,
                  my$prop_f_0r1, my$prop_f_0r2, my$prop_f_0r3, my$prop_f_0r4,
                  my$prop_i_250r1, my$prop_i_250r2, my$prop_i_250r3, my$prop_i_250r4,
                  my$prop_f_250r1, my$prop_f_250r2, my$prop_f_250r3, my$prop_f_250r4),
                  1, median, na.rm = T) # calculate median proportion for each SE deltafit entry

my$mnfit0 <- NA # Calculate the weighted mean generation 0 fitness for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnfit0[i] <- weighted.mean(my[i,c("fit0r1", "fit0r2", "fit0r3", "fit0r4")],
                                    my[i,c("rfit0r1", "rfit0r2", "rfit0r3", "rfit0r4")], na.rm = T)
}

my$mnfit250 <- NA # Calculate the weighted mean generation 250 fitness for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnfit250[i] <- weighted.mean(my[i,c("fit25", "fit25_2", "fit25_3", "fit25_4")],
                                    my[i,c("rfit25", "rfit25_2", "rfit25_3", "rfit25_4")], na.rm = T)
}


# NOT USED IN MODEL-- captures same data as fit0 + fit250
my$mndeltafit <- NA
for(i in 1:nrow(my)){
  my$mndeltafit[i] <- weighted.mean(my[i,c("deltafit", "deltafit_2", "deltafit_3", "deltafit_4")],
                                    my[i,c("rdeltafit", "rdeltafit_2", "rdeltafit_3", "rdeltafit_4")], na.rm = T)
}

my$mnccdeltafit <- NA # Calculate the weighted mean cross contamination rate for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnccdeltafit[i] <- weighted.mean(my[i,c("ccdeltafit", "ccdeltafit_2", "ccdeltafit_3", "ccdeltafit_4")],
                                    my[i,c("rdeltafit", "rdeltafit_2", "rdeltafit_3", "rdeltafit_4")], na.rm = T)
}

my$mnrdeltafit <- apply(cbind(my$rdeltafit, my$rdeltafit_2, my$rdeltafit_3, my$rdeltafit_4),
                       1, mean, na.rm = T) # calculate an updated "sampling effort" value for each SE deltafitness entry 

myfa_w <- my
rm(my, my1, my2, my3, my4, i)
```
<br/><br/>


2: Assess variables that affect SE deltafitness: using sequential term removal via p-value
```{R}
mymod <- lm(I(scale(myfa_w$sedeltafit)) ~ I(scale(myfa_w$mnccdeltafit)) +I(scale(myfa_w$mndeltafit)) +I(scale(myfa_w$medcount)) +I(scale(myfa_w$medprop)) + myfa_w$treatment, weights = myfa_w$mnrdeltafit)
car::vif(mymod) # VIF looks okay.
summary(mymod)

# model output -----------------------------------------------------------------=
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Additional_File_11.html") # r2 on the lm version of htis model is 
# -----------------------------------------------------------------------------
rm(mymod)
```
<br/><br/>


Analysis: Power (Look at the numbers)
```{r}
# POC FIT ASSAY -- GET RMSE & EFFECTSIZE ---------------------------------------
my <- poc92[order(poc92$bcid),] # get data 
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r) # calculate mean corrected init fitness
mymod <- lm(my$rw_corrected ~ my$bcid + 0, weights = my$r); summary(mymod) # model for rmse in POC assays
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~1.76 fitness change 
myeffectsize <- 1/myrmse # effect size of 1 is a 1.76 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse
# ------------------------------------------------------------------------------



# POC FIT ASSAY -- CACULATE ESTIMATED POWER TO DETECT TREAT EFF IN NEXT EXP ----
# power to detect treat effects
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 99.8% power to detect treatment fitness differences of 1.00%
# ------------------------------------------------------------------------------



# POC FIT ASSAY -- CALCULATE POWER TO DETECT FITNESS DIFFERENCE FOR INDIV BCS --
my <- poc92
my1 <- my[my$exp == 1,]; colnames(my1) <- paste0(colnames(my1), "_R1")
my2 <- my[my$exp == 2,]; colnames(my2) <- paste0(colnames(my2), "_R2")
my3 <- my[my$exp == 3,]; colnames(my3) <- paste0(colnames(my3), "_R3")
my4 <- my[my$exp == 4,]; colnames(my4) <- paste0(colnames(my4), "_R4")
my5 <- my[my$exp == 5,]; colnames(my5) <- paste0(colnames(my5), "_R5")
my6 <- my[my$exp == 6,]; colnames(my6) <- paste0(colnames(my6), "_R6")
my7 <- my[my$exp == 7,]; colnames(my7) <- paste0(colnames(my7), "_R7")
my8 <- my[my$exp == 8,]; colnames(my8) <- paste0(colnames(my8), "_R8")
my9 <- my[my$exp == 9,]; colnames(my9) <- paste0(colnames(my9), "_R9")
my10 <- my[my$exp == 10,]; colnames(my10) <- paste0(colnames(my10), "_R10")
poc92_w <- cbind(my1, my2, my3, my4, my5, my6, my7, my8, my9, my10)

for(i in 1:nrow(poc92_w)){
  poc92_w$mnrw[i] <- weighted.mean(poc92_w[i,c("rw_R1", "rw_R2", "rw_R3", "rw_R4", "rw_R5", "rw_R6", "rw_R7", "rw_R8", "rw_R9", "rw_R10")],
                                    poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
  poc92_w$mnr[i] <- rowMeans(poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
}

my <- poc92_w
my$psd_r1 <- ((my$rw_R1-my$mnrw)^2)/10
my$psd_r2 <- ((my$rw_R2-my$mnrw)^2)/10
my$psd_r3 <- ((my$rw_R3-my$mnrw)^2)/10
my$psd_r4 <- ((my$rw_R4-my$mnrw)^2)/10
my$psd_r5 <- ((my$rw_R5-my$mnrw)^2)/10
my$psd_r6 <- ((my$rw_R6-my$mnrw)^2)/10
my$psd_r7 <- ((my$rw_R7-my$mnrw)^2)/10
my$psd_r8 <- ((my$rw_R8-my$mnrw)^2)/10
my$psd_r9 <- ((my$rw_R9-my$mnrw)^2)/10
my$psd_r10 <- ((my$rw_R10-my$mnrw)^2)/10
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4, my$psd_r5, my$psd_r6, my$psd_r7, my$psd_r8, my$psd_r9, my$psd_r10), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnr, na.rm = T)

pow <- pwr.t.test(d= 0.01 / psd, n=4, sig.level = 0.05)
pow$power # 67% power to detect 1% fit change. 

pow <- pwr.t.test(power = 0.8, n=4, sig.level = 0.05)
pow$d*psd # 80% power to detect ~1.2% fitness difference
# ------------------------------------------------------------------------------



# 250 GEN EXP -- GET RMSE & EFFECTSIZE -----------------------------------------
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$deltafit ~ my$bctID + 0, weights = my$rdeltafit); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse
# ------------------------------------------------------------------------------



# 250 GEN EXP -- CACULATE  POWER TO DETECT TREAT EFF ---------------------------
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 87.7% power to detect treatment fitness differences of 1.00%
# ------------------------------------------------------------------------------

# 250 GEN EXP -- CACULATE  POWER TO DETECT TREAT EFF ---------------------------
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), power = 0.8, sig.level = 0.05)
pow$f2*myrmse # 80% power to detect 0.81% fitness difference 
# ------------------------------------------------------------------------------


# 250 GEN EXP -- CALCULATE POWER TO DETECT INDIV BC FIT CHANGE -----------------
# power to detect fitness increase / decrease (t-tests)
# d = m1 - m2 / q; m1 is mean group 1, m2 is mean group 2, q is common standard deviation in the two groups
# here m1 is change in fitness and m2 is 0. mean q is used and is the weighted mean of all
# population standard deviation of the four replicate sets in each row of the dataset.
my <- myfa_w
my$psd_r1 <- ((my$deltafit-my$mndeltafit)^2)/4
my$psd_r2 <- ((my$deltafit_2-my$mndeltafit)^2)/4
my$psd_r3 <- ((my$deltafit_3-my$mndeltafit)^2)/4
my$psd_r4 <- ((my$deltafit_4-my$mndeltafit)^2)/4
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnrdeltafit, na.rm = T)

pow <- pwr.t.test(d= 0.01 / psd, n=4, sig.level = 0.05)
pow # 16% power to detect 1% fit change. 

pow <- pwr.t.test(power = 0.8, n=4, sig.level = 0.05)
pow$d*psd # 80% power to detect ~3% fitness change
# ------------------------------------------------------------------------------



# take a look at gen0 and gen250 rmse in the 250 gen exp -----------------------
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$fit25 ~ my$bctID + 0, weights = my$rfit25); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

my <- myfa[order(myfa$bctID),]
colnames(my)
my$fit0_rep <- NA
my$rfit0_rep <- NA
my$fit0_rep[my$rep == 1] <- my$fit0r1[my$rep == 1]
my$fit0_rep[my$rep == 2] <- my$fit0r2[my$rep == 2]
my$fit0_rep[my$rep == 3] <- my$fit0r3[my$rep == 3]
my$fit0_rep[my$rep == 4] <- my$fit0r4[my$rep == 4]

my$rfit0_rep[my$rep == 1] <- my$rfit0r1[my$rep == 1]
my$rfit0_rep[my$rep == 2] <- my$rfit0r2[my$rep == 2]
my$rfit0_rep[my$rep == 3] <- my$rfit0r3[my$rep == 3]
my$rfit0_rep[my$rep == 4] <- my$rfit0r4[my$rep == 4]

mymod <- lm(my$fit0_rep ~ my$bctID + 0, weights = my$rfit0_rep); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse


rm(my, my1, my10, my2, my3, my4, my5, my6, my7, my8, my9, mymod, pow, i, myeffectsize, myrmse, psd)
```
<br/><br/>


Analysis: Power (Table Output) + Commented Code to produce POWER SURFACE WITH VARIABLE N (COMMENTED VIZ NOT USED IN MANUSCRIPT -- uncomment all commented lines here to create an alternative figure_3 with additional data included)
```{r}
# POC DATA -----------------------------------------------------------------------------------------

# individual bc ----------------------------------------------------------------
my <- poc92 # conduct necessary calculations
my1 <- my[my$exp == 1,]; colnames(my1) <- paste0(colnames(my1), "_R1")
my2 <- my[my$exp == 2,]; colnames(my2) <- paste0(colnames(my2), "_R2")
my3 <- my[my$exp == 3,]; colnames(my3) <- paste0(colnames(my3), "_R3")
my4 <- my[my$exp == 4,]; colnames(my4) <- paste0(colnames(my4), "_R4")
my5 <- my[my$exp == 5,]; colnames(my5) <- paste0(colnames(my5), "_R5")
my6 <- my[my$exp == 6,]; colnames(my6) <- paste0(colnames(my6), "_R6")
my7 <- my[my$exp == 7,]; colnames(my7) <- paste0(colnames(my7), "_R7")
my8 <- my[my$exp == 8,]; colnames(my8) <- paste0(colnames(my8), "_R8")
my9 <- my[my$exp == 9,]; colnames(my9) <- paste0(colnames(my9), "_R9")
my10 <- my[my$exp == 10,]; colnames(my10) <- paste0(colnames(my10), "_R10")
poc92_w <- cbind(my1, my2, my3, my4, my5, my6, my7, my8, my9, my10)

for(i in 1:nrow(poc92_w)){
  poc92_w$mnrw[i] <- weighted.mean(poc92_w[i,c("rw_R1", "rw_R2", "rw_R3", "rw_R4", "rw_R5", "rw_R6", "rw_R7", "rw_R8", "rw_R9", "rw_R10")],
                                    poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
  poc92_w$mnr[i] <- rowMeans(poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
}

my <- poc92_w
my$psd_r1 <- ((my$rw_R1-my$mnrw)^2)/10
my$psd_r2 <- ((my$rw_R2-my$mnrw)^2)/10
my$psd_r3 <- ((my$rw_R3-my$mnrw)^2)/10
my$psd_r4 <- ((my$rw_R4-my$mnrw)^2)/10
my$psd_r5 <- ((my$rw_R5-my$mnrw)^2)/10
my$psd_r6 <- ((my$rw_R6-my$mnrw)^2)/10
my$psd_r7 <- ((my$rw_R7-my$mnrw)^2)/10
my$psd_r8 <- ((my$rw_R8-my$mnrw)^2)/10
my$psd_r9 <- ((my$rw_R9-my$mnrw)^2)/10
my$psd_r10 <- ((my$rw_R10-my$mnrw)^2)/10
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4, my$psd_r5, my$psd_r6, my$psd_r7, my$psd_r8, my$psd_r9, my$psd_r10), na.rm = T)
my$psd <- sqrt(my$psd_m) # get the pop standard dev for each entry
psd <- weighted.mean(my$psd, my$mnr, na.rm = T) # get the weighted mean pop standard dev for reporting

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=22*3, ncol = 5); colnames(mypower) <- c("fitchange", "psd", "n", "power", "sig.level")
mypower <- as.data.frame(mypower)
mypower$fitchange <- c(0.0025, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22)
mypower$psd <- psd
mypower$n <- c(rep(2,22), rep(3,22), rep(4,22))
mypower$power <- NA
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,22), rep(2,22), rep(3,22))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.t.test(d=mypower$fitchange[i] / mypower$psd[i],
                               n=mypower$n[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# model output -----------------------------------------------------------------
mypower2 <- round(mypower[,1:5], digits = 5)
tab_df(mypower2, file = "000_Additional_File_5.html")
# -----------------------------------------------------------------------------


# # Plotting -------------------------------------------------
# # plot effect size x power -------------
# mypower$n <- factor(mypower$n, levels = c(4,3,2))
# p<-ggplot(mypower, aes(x=fitchange, y=power, group=n)) +
#   geom_vline(xintercept = 0.01, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.025, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.1, linetype = "dashed", color = "gray")+
#   geom_line(aes(color=n))+
#   geom_point(aes(color=n))+
#   geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   scale_x_continuous(name = "", breaks = c(0.01, 0.025, 0.05, 0.1), labels = c("1%", "2.5%", "5%", "10%"), limits = c(0, 0.1))+
#   labs(color = "n (replicates \n per timepoint)")+
#   theme_classic()+
#   labs(tag = "A")+
#   theme(legend.position = "none")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# p
# 
# pA <- p



# treatment --------------------------------------------------------------------
# run the appropriate model (fit equivalence model from above -- telling us ability to measure fit for each bcid based on our 10 replicates.)
my <- poc92[order(poc92$bcid),]
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected~ my$bcid + 0, weights = my$r); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~1.76 fitness change 
myeffectsize <- 1/myrmse # effect size of 1 is a 1.76 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse
myv <- (22*2) -1 - 1
mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = myeffectsize, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 

# prepare plot data ----------
mypower <- matrix(nrow=100, ncol = 5); colnames(mypower) <- c("u", "v", "power", "f2", "sig.level")
mypower <- as.data.frame(mypower)
mypower$u <- 1
mypower$v <- c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1)
mypower$power <- NA
mypower$f2 <- c(rep(myeffectsize*2,10), rep(myeffectsize*1.75,10), rep(myeffectsize*1.5,10),
                rep(myeffectsize*1.25,10), rep(myeffectsize*1,10), rep(myeffectsize*.75,10), 
                rep(myeffectsize*.5,10), rep(myeffectsize*.25,10),  rep(myeffectsize*.1,10),  rep(myeffectsize*.05,10))
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,10), rep(2,10), rep(3,10), rep(4,10), rep(5,10), rep(6,10), rep(7,10), rep(8,10), rep(9,10), rep(10,10))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.f2.test(u=mypower$u[i],
                               v=mypower$v[i],
                               f2=mypower$f2[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# model output -----------------------------------------------------------------
mypower2 <- round(mypower[,1:5], digits = 5)
tab_df(mypower2, file = "000_Additional_File_6.html")
# -----------------------------------------------------------------------------

# # plot -----------------------
# myheight <- 7
# mywidth <- 7
# mypower$n <- mypower$v + 2
# mypower$n <- factor(mypower$n, levels =c(myv+2, (myv*0.9)+2, (myv*0.8)+2, (myv*0.7)+2, (myv*0.6)+2, (myv*0.5)+2, (myv*0.4)+2, (myv*0.3)+2, (myv*0.2)+2, (myv*0.1)+2))
# mypower$v <- factor(mypower$v, levels =c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1))
# 
# p<-ggplot(mypower, aes(x=f2, y=power, group=n)) +
#   geom_vline(xintercept = myeffectsize, linetype = "dashed", color = "darkgray")+
#   geom_line(aes(color=n))+
#   geom_point(aes(color=n))+
#   geom_point(x = myeffectsize, y = mypowersize, pch = 1, size = 5, color = "darkgray")+
#   theme_classic()+
#   labs(tag ="B")+
#   labs(color = "n (total barcodes)")+
#   scale_x_continuous(name = "", breaks = c(myeffectsize*0.05, myeffectsize*0.1, myeffectsize*0.25, 
#                                                                                 myeffectsize*0.5, myeffectsize*0.75, myeffectsize, 
#                                                                                 myeffectsize*1.25, myeffectsize*1.5, myeffectsize*1.75, myeffectsize*2), 
#                      labels = c("0.05%","", "0.25%", "0.5%", "0.75%", "1.0%", "1.25%", "1.5%", "1.75%", "2.0%"))+
#   theme(legend.position = "none")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# p
# pB <- p


# 250gen DATA -----------------------------------------------------------------------------------------

# individual BC ----------------------------------------------------------------
# power to detect fitness increase / decrease (t-tests) --------------------------------------------
# d = m1 - m2 / q; m1 is mean group 1, m2 is mean group 2, q is common standard deviation in the two groups
# here m1 is change in fitness and m2 is 0. mean q is used and is the weighted mean of all
# population standard deviation of the four replicate sets in each row of the dataset.

# get data and conduct population sd calculation -----------
my <- myfa_w
my$psd_r1 <- (my$deltafit-my$mndeltafit)^2
my$psd_r2 <- (my$deltafit_2-my$mndeltafit)^2
my$psd_r3 <- (my$deltafit_3-my$mndeltafit)^2
my$psd_r4 <- (my$deltafit_4-my$mndeltafit)^2
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnrdeltafit, na.rm = T)

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=22*3, ncol = 5); colnames(mypower) <- c("fitchange", "psd", "n", "power", "sig.level")
mypower <- as.data.frame(mypower)
mypower$fitchange <- c(0.0025, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22)
mypower$psd <- psd
mypower$n <- c(rep(2,22), rep(3,22), rep(4,22))
mypower$power <- NA
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,22), rep(2,22), rep(3,22))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.t.test(d=mypower$fitchange[i] / mypower$psd[i],
                               n=mypower$n[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# model output -----------------------------------------------------------------
mypower2 <- round(mypower[,1:5], digits = 5)
tab_df(mypower2, file = "000_Additional_File_9.html")
# -----------------------------------------------------------------------------

# # Plotting -------------------------------------------------
# # plot effect size x power -------------
# mypower$n <- factor(mypower$n, levels = c(4,3,2))
# p<-ggplot(mypower, aes(x=fitchange, y=power, group=n)) +
#   geom_vline(xintercept = 0.01, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.025, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray")+
#   geom_vline(xintercept = 0.1, linetype = "dashed", color = "gray")+
#   geom_line(aes(color=n))+
#   geom_point(aes(color=n))+
#   geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
#   scale_x_continuous(name = "Fitness Change", breaks = c(0.01, 0.025, 0.05, 0.1), labels = c("1%", "2.5%", "5%", "10%"), limits = c(0,0.1))+
#   labs(color = "n (replicates \n per timepoint)")+
#   theme_classic()+
#   labs(tag ="C")+
#   theme(legend.direction = "horizontal")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# legend1 <- get_legend(p)
# p <- p + theme(legend.position="none")
# pC <- p





# treatment --------------------------------------------------------------------
# run the appropriate model (fit equivalence model from above -- telling us ability to measure fit for each bcid based on our 10 replicates.)
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$deltafit ~ my$bctID + 0, weights = my$rdeltafit); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treatment effects ------------------------------
myv <- (22*2) -1 - 1
mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = myeffectsize, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=100, ncol = 5); colnames(mypower) <- c("u", "v", "power", "f2", "sig.level")
mypower <- as.data.frame(mypower)
mypower$u <- 1
mypower$v <- c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1)
mypower$power <- NA
mypower$f2 <- c(rep(myeffectsize*2,10), rep(myeffectsize*1.75,10), rep(myeffectsize*1.5,10),
                rep(myeffectsize*1.25,10), rep(myeffectsize*1,10), rep(myeffectsize*.75,10), 
                rep(myeffectsize*.5,10), rep(myeffectsize*.25,10),  rep(myeffectsize*.1,10),  rep(myeffectsize*.05,10))
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,10), rep(2,10), rep(3,10), rep(4,10), rep(5,10), rep(6,10), rep(7,10), rep(8,10), rep(9,10), rep(10,10))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.f2.test(u=mypower$u[i],
                               v=mypower$v[i],
                               f2=mypower$f2[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# model output -----------------------------------------------------------------
mypower2 <- round(mypower[,1:5], digits = 5)
tab_df(mypower2, file = "000_Additional_File_10.html")
# -----------------------------------------------------------------------------

# myheight <- 7
# mywidth <- 7
# mypower$n <- mypower$v + 2
# mypower$n <- factor(mypower$n, levels =c(myv+2, (myv*0.9)+2, (myv*0.8)+2, (myv*0.7)+2, (myv*0.6)+2, (myv*0.5)+2, (myv*0.4)+2, (myv*0.3)+2, (myv*0.2)+2, (myv*0.1)+2))
# mypower$v <- factor(mypower$v, levels =c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1))
# 
# p<-ggplot(mypower, aes(x=f2, y=power, group=n)) +
#   geom_vline(xintercept = myeffectsize, linetype = "dashed", color = "darkgray")+
#   geom_line(aes(color=n))+
#   geom_point(aes(color=n))+
#   geom_point(x = myeffectsize, y = mypowersize, pch = 1, size = 5, color = "darkgray")+
#   theme_classic()+
#   labs(tag = "D")+
#   labs(color = "n (total barcodes \n in two treatments))")+
#   scale_x_continuous(name = "Fitness Difference between Treatments", breaks = c(myeffectsize*0.05, myeffectsize*0.1, myeffectsize*0.25, 
#                                                                                 myeffectsize*0.5, myeffectsize*0.75, myeffectsize, 
#                                                                                 myeffectsize*1.25, myeffectsize*1.5, myeffectsize*1.75, myeffectsize*2), 
#                      labels = c("0.05%","", "0.25%", "0.5%", "0.75%", "1.0%", "1.25%", "1.5%", "1.75%", "2.0%"))+
#   theme(legend.direction = "horizontal")+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# legend2 <- get_legend(p)
# p <- p + theme(legend.position="none")
# p
# pD <- p
# 
# # Plot using grid and output ---------------------------------------------------
# mywidth <- 6.69
# myheight <- 6.69
# pdf(file = "000_Figure_3.pdf", width = mywidth, height = myheight)
# grid.arrange( grid::textGrob("POC Fitness \n Assays", gp =grid::gpar(fontsize = 12, fontface = "bold"), rot = 90),
#               grid::textGrob("250-Generation \n Experiment", gp =grid::gpar(fontsize = 12, fontface = "bold"), rot = 90),
#               pA,pB,
#               pC,pD,
#               legend1, legend2,
#   layout_matrix = rbind(c(1,3,3,3,3,4,4,4,4,4,4),
#                         c(1,3,3,3,3,4,4,4,4,4,4),
#                         c(1,3,3,3,3,4,4,4,4,4,4),
#                         c(1,3,3,3,3,4,4,4,4,4,4),
#                         c(2,5,5,5,5,6,6,6,6,6,6),
#                         c(2,5,5,5,5,6,6,6,6,6,6),
#                         c(2,5,5,5,5,6,6,6,6,6,6),
#                         c(2,5,5,5,5,6,6,6,6,6,6),
#                         c(7,7,7,7,7,7,7,7,7,7,7),
#                         c(8,8,8,8,8,8,8,8,8,8,8)))
# dev.off() # one column wide, equal height
# ------------------------------------------------------------------------------
rm(legend1, legend2, my, my1, my2, my3, my4, my5, my6, my7, my8, my9, my10, mymod, mypower, mypower2, p, pA, pB, pC, pD, pow, i,
   myeffectsize, myheight, mypowersize, myrmse, myv, mywidth, psd)
```
<br/><br/>


Analysis: Power (Vizualize for Methods manuscript)
```{r}
# individual bc ------------------------------------------------------------------------------------
# # POC DATA -------------------------------------------------------------------
my <- poc92 # conduct necessary calculations
my1 <- my[my$exp == 1,]; colnames(my1) <- paste0(colnames(my1), "_R1")
my2 <- my[my$exp == 2,]; colnames(my2) <- paste0(colnames(my2), "_R2")
my3 <- my[my$exp == 3,]; colnames(my3) <- paste0(colnames(my3), "_R3")
my4 <- my[my$exp == 4,]; colnames(my4) <- paste0(colnames(my4), "_R4")
my5 <- my[my$exp == 5,]; colnames(my5) <- paste0(colnames(my5), "_R5")
my6 <- my[my$exp == 6,]; colnames(my6) <- paste0(colnames(my6), "_R6")
my7 <- my[my$exp == 7,]; colnames(my7) <- paste0(colnames(my7), "_R7")
my8 <- my[my$exp == 8,]; colnames(my8) <- paste0(colnames(my8), "_R8")
my9 <- my[my$exp == 9,]; colnames(my9) <- paste0(colnames(my9), "_R9")
my10 <- my[my$exp == 10,]; colnames(my10) <- paste0(colnames(my10), "_R10")
poc92_w <- cbind(my1, my2, my3, my4, my5, my6, my7, my8, my9, my10)

for(i in 1:nrow(poc92_w)){
  poc92_w$mnrw[i] <- weighted.mean(poc92_w[i,c("rw_R1", "rw_R2", "rw_R3", "rw_R4", "rw_R5", "rw_R6", "rw_R7", "rw_R8", "rw_R9", "rw_R10")],
                                    poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
  poc92_w$mnr[i] <- rowMeans(poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
}

my <- poc92_w
my$psd_r1 <- ((my$rw_R1-my$mnrw)^2)/10
my$psd_r2 <- ((my$rw_R2-my$mnrw)^2)/10
my$psd_r3 <- ((my$rw_R3-my$mnrw)^2)/10
my$psd_r4 <- ((my$rw_R4-my$mnrw)^2)/10
my$psd_r5 <- ((my$rw_R5-my$mnrw)^2)/10
my$psd_r6 <- ((my$rw_R6-my$mnrw)^2)/10
my$psd_r7 <- ((my$rw_R7-my$mnrw)^2)/10
my$psd_r8 <- ((my$rw_R8-my$mnrw)^2)/10
my$psd_r9 <- ((my$rw_R9-my$mnrw)^2)/10
my$psd_r10 <- ((my$rw_R10-my$mnrw)^2)/10
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4, my$psd_r5, my$psd_r6, my$psd_r7, my$psd_r8, my$psd_r9, my$psd_r10), na.rm = T)
my$psd <- sqrt(my$psd_m) # get the pop standard dev for each entry
psd <- weighted.mean(my$psd, my$mnr, na.rm = T) # get the weighted mean pop standard dev for reporting
psdpoc <- psd
# prepare plot data ----------------------------------------
mypower <- matrix(nrow=22*3, ncol = 5); colnames(mypower) <- c("fitchange", "psd", "n", "power", "sig.level")
mypower <- as.data.frame(mypower)
mypower$fitchange <- c(0.0025, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22)
mypower$psd <- psd
mypower$n <- c(rep(2,22), rep(3,22), rep(4,22))
mypower$power <- NA
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,22), rep(2,22), rep(3,22))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.t.test(d=mypower$fitchange[i] / mypower$psd[i],
                               n=mypower$n[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}
mypower$n <- factor(mypower$n, levels = c(4,3,2))
mypower <- mypower[mypower$n == 4,]
mypower_a_poc <- mypower
mypower_a_poc$exp <- "POC Fitness Assays"

# # 250 gen DATA -------------------------------------------------------------------
# power to detect fitness increase / decrease (t-tests) --------------------------------------------
# d = m1 - m2 / q; m1 is mean group 1, m2 is mean group 2, q is common standard deviation in the two groups
# here m1 is change in fitness and m2 is 0. mean q is used and is the weighted mean of all
# population standard deviation of the four replicate sets in each row of the dataset.

# get data and conduct population sd calculation -----------
my <- myfa_w
my$psd_r1 <- (my$deltafit-my$mndeltafit)^2
my$psd_r2 <- (my$deltafit_2-my$mndeltafit)^2
my$psd_r3 <- (my$deltafit_3-my$mndeltafit)^2
my$psd_r4 <- (my$deltafit_4-my$mndeltafit)^2
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnrdeltafit, na.rm = T)
psd250 <- psd
# prepare plot data ----------------------------------------
mypower <- matrix(nrow=22*3, ncol = 5); colnames(mypower) <- c("fitchange", "psd", "n", "power", "sig.level")
mypower <- as.data.frame(mypower)
mypower$fitchange <- c(0.0025, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22)
mypower$psd <- psd
mypower$n <- c(rep(2,22), rep(3,22), rep(4,22))
mypower$power <- NA
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,22), rep(2,22), rep(3,22))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.t.test(d=mypower$fitchange[i] / mypower$psd[i],
                               n=mypower$n[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}
mypower$n <- factor(mypower$n, levels = c(4,3,2))
mypower <- mypower[mypower$n == 4,]
mypower_a_250 <- mypower
mypower_a_250$exp <- "250 Generation Evolution Fitness Assays"
mypower <- rbind(mypower_a_poc, mypower_a_250)
mypower$exp <- as.factor(mypower$exp)
mypower$exp <- relevel(mypower$exp, ref = "POC Fitness Assays")

# Plotting -------------------------------------------------
# plot effect size x power -------------
p<-ggplot(mypower, aes(x=fitchange, y=power, group=exp)) +
  geom_vline(xintercept = 0.01, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.025, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.1, linetype = "dashed", color = "gray")+
  geom_line(aes(color=exp))+
  geom_point(aes(color=exp))+
  geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psdpoc, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psdpoc, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psdpoc, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psdpoc, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psd250, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psd250, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psd250, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psd250, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  scale_x_continuous(name = "Fitness difference (& fitness change) \n for individual barcodes \n ", breaks = c(0.01, 0.025, 0.05, 0.1), labels = c("1%", "2.5%", "5%", "10%"), limits = c(0,0.1))+
  scale_color_manual(values =setpalette) + 
  labs(color = "Experiment")+
  theme_classic()+
  labs(tag ="A")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
legend1 <- get_legend(p)
p <- p + theme(legend.position="none")
pA <- p
pA







# treatment ----------------------------------------------------------------------------------------
# # POC DATA -------------------------------------------------------------------
# run the appropriate model (fit equivalence model from above -- telling us ability to measure fit for each bcid based on our 10 replicates.)
my <- poc92[order(poc92$bcid),]
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected~ my$bcid + 0, weights = my$r); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~1.76 fitness change 
myeffectsize <- 1/myrmse # effect size of 1 is a 1.76 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse
myv <- (22*2) -1 - 1
mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = myeffectsize, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 

# prepare plot data ----------
mypower <- matrix(nrow=100, ncol = 5); colnames(mypower) <- c("u", "v", "power", "f2", "sig.level")
mypower <- as.data.frame(mypower)
mypower$u <- 1
mypower$v <- c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1)
mypower$power <- NA
mypower$f2 <- c(rep(myeffectsize*2,10), rep(myeffectsize*1.75,10), rep(myeffectsize*1.5,10),
                rep(myeffectsize*1.25,10), rep(myeffectsize*1,10), rep(myeffectsize*.75,10), 
                rep(myeffectsize*.5,10), rep(myeffectsize*.25,10),  rep(myeffectsize*.1,10),  rep(myeffectsize*.05,10))
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,10), rep(2,10), rep(3,10), rep(4,10), rep(5,10), rep(6,10), rep(7,10), rep(8,10), rep(9,10), rep(10,10))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.f2.test(u=mypower$u[i],
                               v=mypower$v[i],
                               f2=mypower$f2[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

mypower$n <- mypower$v + 2
mypower$n <- factor(mypower$n, levels =c(myv+2, (myv*0.9)+2, (myv*0.8)+2, (myv*0.7)+2, (myv*0.6)+2, (myv*0.5)+2, (myv*0.4)+2, (myv*0.3)+2, (myv*0.2)+2, (myv*0.1)+2))
mypower$v <- factor(mypower$v, levels =c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1))
mypower <- mypower[mypower$n == 44,]
mypower$f2 <- mypower$f2*myrmse
mypower_b_poc <- mypower
mypower_b_poc$exp <- "POC Fitness Assays"
myeffectsize_b_poc <- myeffectsize*myrmse
mypowersize_b_poc <- mypowersize

# 250gen DATA -----------------------------------------------------------------------------------------
# run the appropriate model (fit equivalence model from above -- telling us ability to measure fit for each bcid based on our 10 replicates.)
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$deltafit ~ my$bctID + 0, weights = my$rdeltafit); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treatment effects ------------------------------
myv <- (22*2) -1 - 1
mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = myeffectsize, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=100, ncol = 5); colnames(mypower) <- c("u", "v", "power", "f2", "sig.level")
mypower <- as.data.frame(mypower)
mypower$u <- 1
mypower$v <- c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1)
mypower$power <- NA
mypower$f2 <- c(rep(myeffectsize*2,10), rep(myeffectsize*1.75,10), rep(myeffectsize*1.5,10),
                rep(myeffectsize*1.25,10), rep(myeffectsize*1,10), rep(myeffectsize*.75,10), 
                rep(myeffectsize*.5,10), rep(myeffectsize*.25,10),  rep(myeffectsize*.1,10),  rep(myeffectsize*.05,10))
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,10), rep(2,10), rep(3,10), rep(4,10), rep(5,10), rep(6,10), rep(7,10), rep(8,10), rep(9,10), rep(10,10))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.f2.test(u=mypower$u[i],
                               v=mypower$v[i],
                               f2=mypower$f2[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

mypower$n <- mypower$v + 2
mypower$n <- factor(mypower$n, levels =c(myv+2, (myv*0.9)+2, (myv*0.8)+2, (myv*0.7)+2, (myv*0.6)+2, (myv*0.5)+2, (myv*0.4)+2, (myv*0.3)+2, (myv*0.2)+2, (myv*0.1)+2))
mypower$v <- factor(mypower$v, levels =c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1))
mypower <- mypower[mypower$n == 44,]
mypower$f2 <- mypower$f2*myrmse
mypower_b_250 <- mypower
mypower_b_250$exp <- "250 Generation Evolution Fitness Assays"
myeffectsize_b_250 <- myeffectsize*myrmse
mypowersize_b_250 <- mypowersize
mypower <- rbind(mypower_b_poc, mypower_b_250)
mypower$exp <- as.factor(mypower$exp)
mypower$exp <- relevel(mypower$exp, ref = "POC Fitness Assays")

# Plotting -------------------------------------------------
# plot effect size x power -------------
p<-ggplot(mypower, aes(x=f2, y=power, group=exp)) +
  geom_vline(xintercept = myeffectsize_b_poc, linetype = "dashed", color = "darkgray")+
  geom_vline(xintercept = myeffectsize_b_250, linetype = "dashed", color = "darkgray")+
  geom_line(aes(color=exp))+
  geom_point(aes(color=exp))+  
  geom_point(x = myeffectsize_b_poc, y = mypowersize_b_poc, pch = 1, size = 5, color = "darkgray")+
  geom_point(x = myeffectsize_b_250, y = mypowersize_b_250, pch = 1, size = 5, color = "darkgray")+
  theme_classic()+
  labs(tag = "B")+
  labs(color = "n (total barcodes \n in two treatments))")+
  scale_x_continuous(name = "Fitness difference between treatments \n ", breaks = c(0.05, 0.1, 0.25,
                                                                                0.5, 0.75, 1.0,
                                                                                1.25, 1.5, 1.75, 2),
                     labels = c("0.05%","", "0.25%", "0.5%", "0.75%", "1.0%", "1.25%", "1.5%", "1.75%", "2.0%"))+
  scale_color_manual(values =setpalette) + 
  theme(legend.position = "none")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
pB <- p
pB

# Plot using grid and output ---------------------------------------------------
mywidth <- 3.345
myheight <- 6.69
pdf(file = "000_Figure_3.pdf", width = mywidth, height = myheight)
grid.arrange(pA,pB,
            legend1,
  layout_matrix = rbind(c(1,1,1,1),
                        c(1,1,1,1),
                        c(1,1,1,1),
                        c(1,1,1,1),
                        c(2,2,2,2),
                        c(2,2,2,2),
                        c(2,2,2,2),
                        c(2,2,2,2),
                        c(3,3,3,3)))
dev.off() # one column wide, equal height
# ------------------------------------------------------------------------------
rm(legend1, legend2, my, my1, my2, my3, my4, my5, my6, my7, my8, my9, my10, mymod, mypower, mypower2, p, pA, pB, pC, pD, pow, i,
   myeffectsize, myheight, mypowersize, myrmse, myv, mywidth, psd, mypower_a_250, mypower_a_poc, mypower_b_250, mypower_b_poc,
   myeffectsize_b_250, myeffectsize_b_poc, mypowersize_b_250, mypowersize_b_poc, psd250, psdpoc)
```
<br/><br/>



Analysis: Assess effects of evoluitonary treatment on change in fitness in 250-generations of experimental evolution. 
```{r}
my <- myfa[order(myfa$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
mymod <- lmer(I(scale(deltafit)) ~ I(scale(ccdeltafit)) +treatment +(1|bctID), weights = rdeltafit, data = my, control=lmerControl(optimizer ="bobyqa",optCtrl=list(maxfun=2e4)))
# model output -----------------------------------------------------------------=
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Additional_File_13.html")
# -----------------------------------------------------------------------------


my <- myfa_w[order(myfa_w$bctID),] # placeholder dataframe
my <- my[my$sedeltafit < 0.029,]
min(my$mndeltafit)
max(my$mndeltafit)

myx <- my$treatment
myy <- my$mndeltafit
myr <- my$mnrdeltafit
myc <- my$treatment

mytitle <- NULL
myylab <- "Fitness change"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.345
mywidth <- 6.69
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 1:1000", "CM+EtOH \n Diploid \n 1:1000", "CM+NaCl \n Diploid \n 1:1000", "CM \n Diploid \n 1:4000", "CM \n Diploid \n 1:250", "CM \n Haploid \n 1:1000")) +
  scale_y_continuous(breaks = seq(-.05,.25,by=.05),
                     labels = c("-0.05", "0", "0.05", "0.1", "0.15", "0.2", "0.25"),
                     limits = c(-.05, .25))+
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(2,3,4,5,6), y=c(.065,.25,.045,.095,.115), label = c("**", "***", "", "***", "*"), size = 8, fontface = "bold")
  
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_5.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, weights)
rm(p, myc, myfill, myfillapha, myheight, mylinealpha, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, myx, myxlab, mywidth, myy, myylab)
```
<br/><br/>



Analysis: Calculate fixation rate summaries by treatment for the 250-generation experiment. 
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# Review Results --------------------------------------------------------------
paste0("proportion of wells that attained fixation (n=76 total wells)= ", nrow(my[my$fixed == T,])/nrow(my))  # prop fixed

# CM diploid 1:1000
myt <- my[my$treatment == "CMdiploid0.001",]; paste0("n wells in CMdiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM haploid 1:1000
myt <- my[my$treatment == "CMhaploid0.001",]; paste0("n wells in CMhaploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM+Salt diploid 1:1000
myt <- my[my$treatment == "CM+Saltdiploid0.001",]; paste0("n wells in CM+Saltdiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM+Ethanol 1:1000
myt <- my[my$treatment == "CM+Ethanoldiploid0.001",]; paste0("n wells in CM+Ethanoldiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM diploid 1:250
myt <- my[my$treatment == "CMdiploid0.004",]; paste0("n wells in CMdiploid0.004 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM diploid 1:4000
myt <- my[my$treatment == "CMdiploid0.00025",]; paste0("n wells in CMdiploid0.00025 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed
# -----------------------------------------------------------------------------
rm(my, myt)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX (generation of maximum deviation from generation-0 barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxdev ~ my$treatment + my$ccmaxdev_t0 + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tmaxdev ~ my$treatment + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tmaxdev ~ my$treatment + my$ccmaxdev, weights = my$rmaxdev); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxdev ~ my$treatment, weights = my$rmaxdev); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxdev), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_14.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxdev
myr <- my$rmaxdev
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX (Generation)"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  # geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3), y=c(255), label = "*", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_15.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX (magnitude of maximum deviation from generation-0 barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxdev ~ my$treatment + my$ccmaxdev_t0 + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$mmaxdev ~ my$treatment + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without:
# mymod <- glm(my$mmaxdev ~ my$treatment + my$ccmaxdev, weights = my$rmaxdev); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxdev ~ my$treatment, weights = my$rmaxdev); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxdev), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_16.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxdev
myr <- my$rmaxdev
myc <- my$treatment

mytitle <- NULL
myylab <- "M-MAX"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3,6), y=c(0.91,0.765), label = c("***", "**"), size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_17.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab, myfillapha, mylinealpha)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX-RATE (generation of maximum rate of change in barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxrate ~ my$treatment + my$ccmaxrate_t0 + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tmaxrate ~ my$treatment + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tmaxrate ~ my$treatment + my$ccmaxrate, weights = my$rmaxrate); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxrate ~ my$treatment, weights = my$rmaxrate); summary(mymod) # Final model!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxrate), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_18.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxrate
myr <- my$rmaxrate
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX-RATE"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  # geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(6), y=c(257), label = "***", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_19.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX-RATE (magnitude of maximum rate of change in barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxrate ~ my$treatment + my$ccmaxrate_t0 + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$mmaxrate ~ my$treatment + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$mmaxrate ~ my$treatment + my$ccmaxrate, weights = my$rmaxrate); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxrate ~ my$treatment, weights = my$rmaxrate); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxrate), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_20.html")

# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxrate
myr <- my$rmaxrate
myc <- my$treatment

mytitle <- NULL
myylab <-"M-MAX-RATE"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(4), y=c(0.0325), label = "*", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_21.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX-DIFF (generation of maximum difference in sympatric barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxdiff ~ my$treatment + my$ccmaxdiff_t0 + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxdiff ~ my$treatment + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod)# # FINAL MODEL!

anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_22.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxdiff
myr <- my$rmaxdiff_rt0
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX-DIFF"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_23.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX-DIFF (magnitude of maximum difference in sympatric barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxdiff ~ my$treatment + my$ccmaxdiff_t0 + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxdiff ~ my$treatment + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod)# # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_24.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxdiff
myr <- my$rmaxdiff_rt0
myc <- my$treatment

mytitle <- NULL
myylab <- "M-MAX-DIFF"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3,6), y=c(0.525), label = "***", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_25.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on total change in barcode abundance (summed across six intervals)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tcc ~ my$treatment + my$cctcc_t0 + my$diff0, weights = my$rtcc_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tcc ~ my$treatment + my$diff0, weights = my$rtcc_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tcc ~ my$treatment + my$cctcc, weights = my$rtcc); summary(mymod) # drop c as least significant term
mymod <- lm(my$tcc ~ my$treatment, weights = my$rtcc); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_26.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tcc
myr <- my$rtcc
myc <- my$treatment

mytitle <- NULL
myylab <- "Total Change in Abundance"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myptalpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(2,4,6), y=c(0.0275,0.06825,0.026), label = c("*","**","*"), size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Additional_File_27.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p, myc, myfill, myheight, myoutline, mypalette, myptalpha, myptsize, myr, mytextsize, mytitle, mywidth, myx, myxlab, myy, myylab)
```
<br/><br/>

