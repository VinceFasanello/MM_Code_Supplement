---
title: "Analyze.rmd"
output:
  html_document:
    df_print: paged
---
***
#### Description:  
|   This script takes inputs in the form of counts matrices and dataframes 
|   formatted for analysis by the CountstoAnalysis scripts for the 001 and
|   002 datasets (with all calculations and formatting already completed) --
|   See Inputs for all inputs. The script then conducts all summary 
|   calculations, statistical tests, and produces all visuals and output tables
|   found in the main text and supplement (unless otherwise noted below -- see 
|   Outputs). Code blocks appear in more-or-less the same order that data are 
|   presented in the text; brief descriptions head each box and more detailed 
|   code can be found in-line. This script outputs a set of figures and tables 
|   that are included, some with modification and stylization, in the main text 
|   and supplement. 

***
#### Inputs:  
1.    poc1.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay single-barcode controls.
2.    poc2.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay dual-barcode controls.
3.    poc92.Rdata -- CountstoAnalysis formatted dataframe for POC fitness assay fitness assay samples.
4.    001_counts.expected.Rdata --  FastqtoCounts formatted matrix for POC fitness assay library expected (by design) counts.
5.    001_counts.unexpected.Rdata --  FastqtoCounts formatted matrix for POC fitness assay library unexpected (barcode cross-contamination) counts.
6.    002_CC_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- consensus matrix constructed from two sequenced libraries.
7.    002_CC_counts.unexpected.Rdata --  FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- consensus matrix from two sequenced libraries.
8.    002_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- original sequenced library.
9.    002_counts.unexpected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- original sequenced library.
10.   002_Reruns_counts.expected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment expected (by design) counts -- resequenced samples library.
11.   002_Reruns_counts.unexpected.Rdata -- FastqtoCounts formatted matrix 250-generation evolution experiment unexpected (barcode cross-contamination) counts -- resequenced samples library.
12.   myfa.Rdata -- CountstoAnalysis formatted dataframe for 250-generation experimental evolution project fitness assays.
13.   myevo.Rdata -- CountstoAnalysis formatted dataframe for 250-generation experimental evolution project longitudinal samples.


***
#### Outputs:   
1.  000_Figure_2.pdf -- Manuscript Figure 2 output as .pdf file.  
2.  000_Figure_3.pdf -- Manuscript Figure 3 output as .pdf file. 
3.  000_Figure_4.pdf -- Manuscript Figure 4 output as .pdf file. 

4.  000_Figure_S1.pdf -- Manuscript Figure S1 panel a&b. output as .pdf file. 
5.  000_Figure_S2.pdf -- Manuscript Figure S2 output as .pdf file. 
6.  000_Figure_S3.pdf -- Manuscript Figure S3 output as .pdf file. 
7.  000_Figure_S4.pdf -- Manuscript Figure S4 output as .pdf file. 
8.  000_Figure_S5.pdf -- Manuscript Figure S5 output as .pdf file. 
9. 000_Figure_S6.pdf -- Manuscript Figure S6 output as .pdf file. 
10. 000_Figure_S7.pdf -- Manuscript Figure S7 output as .pdf file. 
11. 000_Figure_S8.pdf -- Manuscript Figure S8 output as .pdf file. 
12. 000_Figure_S9.pdf -- Manuscript Figure S9 output as .pdf file.

15. 000_Table_S4.html -- Raw Manuscript Figure S4 output as .html file. File later stylized in excel and P-values converted to fdr for publication.
16. 000_Table_S5.html
17. 000_Table_S6.html
18. 000_Table_S7.html
19. 000_Table_S8.html

10. 000_Table_S9.html -- Raw Manuscript Figure S7 output as .html file. File later stylized in excel.
21. 000_Table_S10.html -- Raw Manuscript Figure S8 output as .html file. File later stylized in excel and P-values converted to 1-sided (higher) and fdr for publication.
22. 000_Table_S11.html -- Raw Manuscript Figure S9 output as .html file. File later stylized in excel.
23. 000_Table_S12.html -- Raw Manuscript Figure S10 output as .html file. File later stylized in excel.
24. 000_Table_S13.html -- Raw Manuscript Figure S11 output as .html file. File later stylized in excel.
25. 000_Table_S14.html -- Raw Manuscript Figure S12 output as .html file. File later stylized in excel.
26. 000_Table_S15.html -- Raw Manuscript Figure S13 output as .html file. File later stylized in excel.
27. 000_Table_S16.html -- Raw Manuscript Figure S14 output as .html file. File later stylized in excel.
28. 000_Table_S17.html -- Raw Manuscript Figure S15 output as .html file. File later stylized in excel.

* Table_S4 through Table_S16 are all stylized and formatted in Excel and converted to .xlsx files from .html (if originally .html formatted) for publication.
** Table_S4 is output with raw p-values, but values are converted to fdr for publication. Table_S8 is output with raw 2-sided test p-values, but values are converted to 1-sided (higher) and fdr for publication. 
*** Figure_1, Figure_5 are not output by this script. They are manually created in Keynote and Excel, respectively. 
**** Table_S1, Table_S2, and Table_S3 are not output by this script. They are manually created in Excel.


***
### Begin Code Blocks:

Prepare the workspace: clean, set options, load packages, load and final formatting on inputs.
```{r, warning = FALSE, message=FALSE}
rm(list = ls()) # clear workspace
knitr::opts_chunk$set(tidy = TRUE, collapse = TRUE) # set global knitr options.
# load required packages
require(ggplot2); # used for plotting #check#
require(pwr); # used for power analysis
require(lme4); # used for mixed effects models #check#
require(lmerTest); # used to interpret mixed effects models #check#
require(sjPlot); # used to output tables #check#
require(weights); # used for weighted t.test #check#
require(plyr); # used for dataframe manipulation #check#
require(gridExtra) # used for multipanel plotting #check#
require(MuMIn) # model seleciton and multimodel inference

options(scipen = 999) # turn off scientific notation
```
<br/><br/>



```{r, warning = FALSE, message=FALSE}
getwd()

dir_in_pocpro <- "2_CountstoAnalysis/001_Prepare_Datasets" # input directory for Proof of concept processed dataframes
setwd("..")
setwd(dir_in_pocpro) # set to above directory path
load(file = "poc1.Rdata") # load the 1bc control processed dataframe
load(file = "poc2.Rdata") # load the 2 bc control processed dataframe
load(file = "poc92.Rdata") # load the 92 bc proof of concept fitness assays processed dataframe

dir_in_pocraw <- "001_Raw_Data_Metadata"  # input directory for Proof of concept raw dataframes
setwd("..")
setwd(dir_in_pocraw) # set to above directory path
load(file = "001_counts.expected.Rdata"); poc.ce <- (counts.expected + 1)[c(1:92),]; rm(counts.expected) # expected counts
load(file = "001_counts.unexpected.Rdata"); poc.cc <- (counts.unexpected + 1)[c(1:92),]; rm(counts.unexpected) # cross contamination counts. 

dir_in_faevoraw <- "002_Raw_Data_Metadata" # input directory for FA and Evo raw dataframes
setwd("..")
setwd(dir_in_faevoraw) # set to above directory path
load(file = "002_CC_counts.expected.Rdata"); faevo.ce <- (ects + 0); rm(ects) # expected counts {combined}
load(file = "002_CC_counts.unexpected.Rdata"); faevo.cc <- (ccts + 0); rm(ccts) # cross contamination counts.{combined}
load(file = "002_counts.expected.Rdata"); faevo.1.ce <- (counts.expected + 1)[c(1:78),]; rm(counts.expected) # expected counts {first run samples}
load(file = "002_counts.unexpected.Rdata"); faevo.1.cc <- (counts.unexpected + 1)[c(1:78),]; rm(counts.unexpected) # cross contamination counts. {first run samples}
load(file = "002_Reruns_counts.expected.Rdata"); faevo.2.ce <- (counts.expected + 1)[c(1:78),]; rm(counts.expected) # expected counts {rerun samples}
load(file = "002_Reruns_counts.unexpected.Rdata"); faevo.2.cc <- (counts.unexpected + 1)[c(1:78),]; rm(counts.unexpected) # cross contamination counts. {rerun samples}

dir_in_faevopro <- "002_Prepare_Datasets" # input directory for FA and Evo processed dataframes
setwd("..")
setwd(dir_in_faevopro) # set to above directory path
load(file = "myfa.Rdata") # fitness assay
load(file = "myevo.Rdata") # evolution
rm(dir_in_faevopro, dir_in_faevoraw, dir_in_pocpro, dir_in_pocraw)
```
<br/><br/>



Create helper functions for linear model residual plotting and data transformation.
```{r, warning = FALSE, message=FALSE}
# expand_residuals creates a modified histogram of residuals. Each entry in the model output is plotted a number of times equal to its reads.
expand_residuals <- function(model, reads){
  myfr <- NA
  for(i in 1:length(residuals(model))){
    times <- (((reads[i] - min(reads, na.rm = T))/(max(reads) - min(reads)))*1000) + 1 
    myfr <- c(myfr, rep(residuals(model)[i], times = times))
  }
  return(myfr)
}

# log transformation for modeling. 
log_transform <- function(myvar){
  myvar <- log(((myvar - min(myvar))/(max(myvar) - min(myvar))) + 1) 
  return(myvar)
}
```
<br/><br/>



Set color palette options for all plots
```{r}
setpalette <- RColorBrewer::brewer.pal(6, "Dark2") # current preferred palette
#setpalette <- c("#993404","#d95f0e","#fe9929","#41b6c4","#2c7fb8","#253494") # option 2
#setpalette <- c("#8c510a","#d8b365","#f6e8c3", "#c7eae5","#5ab4ac","#01665e") # option 3
```
<br/><br/>



Analysis: Assess POC fitness assay barcode fitness equivalence.
```{r}
my <- poc92[order(poc92$bcid),]

# model & diagnostic plots ----------------------------------------------------
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected~ my$bcid + 0, weights = my$r); summary(mymod)
hist(residuals(mymod), breaks = 50) # residuals look good, check the other diagnostic plots too...
hist(expand_residuals(mymod, my$r), breaks = 50) # this more accurately represents the distribution of residuals in the model output.
plot(mymod) # view the diagnostic plots
paste0("Number of BCs with fitness different than pop mean = ",
       sum(p.adjust(coef(summary(mymod))[,4], method = "fdr") < 0.05)) # number of barcodes with fit different than pop weighted mean. 
paste0("RsMSE = ",
       sqrt(mean(residuals(mymod)^2))) # report rmse (requires unscalled lm model)
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T,  wrap.labels = 100, file = "000_Table_S4.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T,  wrap.labels = 100, file = "000_Additional_File_4.html")
# -----------------------------------------------------------------------------

# create temporary plotting dataframe -----------------------------------------
myres <- as.data.frame(coef(summary(mymod)), stringsAsFactors = F) # create a myres dataframe to aid in plotting. 
myres$p.adjust <- p.adjust(myres$`Pr(>|t|)`, method = "fdr")
myres$bcid <-  gsub("^.*?d","",rownames(myres)) # fix barcode id names
myres$mrw <- ddply(my, ~bcid, function(my) weighted.mean(my$rw, my$r))[,2]
myres$rmrw <- ddply(my, ~bcid, function(my) mean(my$r))[,2]
myres$mcmrw <- myres$mrw - weighted.mean(myres$mrw, myres$rmrw)
myres$color <- "fdr > 0.05"; myres$color[myres$p.adjust <= 0.05] <- "fdr <= 0.05"
myres$color <- as.factor(myres$color); myres$color <- relevel(myres$color, "fdr > 0.05")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myres$mcmrw
myr <- myres$rmrw
myc <- myres$color
mybinwidth <- 0.0025

mytitle <- NULL
myylab <- "Count"
myxlab <- "Fitness difference from population mean"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 3.345 
mywidth <- 3.345

p <- ggplot(myres, aes(x=myx, color = myc, fill = myc)) + 
  geom_histogram(alpha = myfillapha, position = "identity", binwidth = mybinwidth) +
  geom_rug(alpha = myptalpha)+
  #xlim(c(-0.06, 0.06)) +
  ylim(c(NA,15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = myhighlight) +
  scale_color_manual(values =mypalette, guide = FALSE) + 
  scale_fill_manual(values =mypalette) +
  theme_classic() +
  theme(legend.position= c(0.8,0.8)) +
  labs(fill = "Significance") +
  ggtitle(mytitle)+ ylab(myylab)+ xlab(myxlab)+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  theme(legend.title = element_text(size = mytextsize, face = "bold"))+
  theme(legend.text = element_text(size = mytextsize))+
  scale_x_continuous(breaks = seq(-0.06,0.06,by=0.01), 
                     labels = c("-0.06", "", "-0.04", "", "-0.02", "", "0", "", "0.02", "", "0.04", "", "0.06"),
                     limits = c(-0.06, 0.06))
p
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_2.pdf", width = mywidth, height = myheight); p; dev.off() # one column wide, equal height

# -----------------------------------------------------------------------------
rm(p, myres, mymod, my)
```
<br/><br/>



Analysis: Calculate sequenced library reads summary values
```{r}
paste0("matching counts (match f and r primer barcode, and moby bc): ", sum(c(poc.ce, poc.cc, faevo.1.ce, faevo.1.cc, faevo.2.ce, faevo.2.cc), na.rm = T)) # match forward primer, reverse primer, and yeast strain BCs
paste0("analysis counts: ", sum(c(poc.ce, poc.cc, faevo.ce, faevo.cc), na.rm = T)) # expected and cc counts in the analysis data
paste0("expected analysis counts: ", sum(c(poc.ce,faevo.ce), na.rm = T)) # expected counts in the analysis data
paste0("median counts per barcode: ",median(c(poc.ce, faevo.ce),  na.rm = T)) # median number of counts per barcode in the expected counts dataset.
```
<br/><br/>



Analysis: Assess POC library barcode cross-contamination rate.
```{r}
# calculations ----------------------------------------------------------------
cc = (((colSums(poc.cc, na.rm = T)) / (colSums(poc.ce, na.rm = T) + colSums(poc.cc, na.rm = T))) / colSums(!is.na(poc.cc)))*100 # cc rate per exp
cc[is.nan(cc)] <- NA # NA nans
myt <- as.data.frame(cc) # convert to dataframe
myt$tc <- (colSums(poc.ce, na.rm = T) + colSums(poc.cc, na.rm = T)) # total counts to use as weight in weighted mean
cc001 <- weighted.mean(myt$cc, myt$tc, na.rm = T) # save weighted mean cc (by expected reads) for grand cc rate. 
r001 <- mean(myt$tc) # save mean for below calculation of grand cc rate. 
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myt$cc
myr <- myt$tc
myc <- setpalette[1]

mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Mean Barcode Contamination Rate (Percent Total Counts)"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mytextsize <- 8
myheight <- 3.5
mywidth <- 7

p_a <- ggplot(myt, aes(x=myx)) +
  geom_histogram(alpha = myfillapha ,color = myc, fill = myc,  binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx, myr, na.rm = T), linetype = "dashed", color = myhighlight) +
  geom_rug(color = myc, alpha = myptalpha)+
  xlim(NA, 1.0) +
  theme_classic() +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab) +
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  annotate("text", x = 1, y = 47, label = "A", size = 10)
p_a
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
#pdf(file = "000_Figure_S1_A.pdf", width = mywidth, height = myheight); p; dev.off()  # 2columns wide, half as tall
# -----------------------------------------------------------------------------
rm(cc, myt) # remove the temporary variable
```
<br/><br/>



Analysis: Assess 250-generation experiment consensus library barcode cross-contamination rate.
```{r}
# Calculations ----------------------------------------------------------------
cc = ((colSums(faevo.cc, na.rm = T)) / (colSums(faevo.ce, na.rm = T) + colSums(faevo.cc, na.rm = T))) / colSums(!is.na(faevo.cc))*100 # cc rate per exp
cc[is.nan(cc)] <- NA # NA nans
myt <- as.data.frame(cc) # convert to dataframe
myt$tc <- (colSums(faevo.ce, na.rm = T) + colSums(faevo.cc, na.rm = T)) # total counts to use as weight in weighted mean
cc002 <-  weighted.mean(myt$cc, myt$tc, na.rm = T)  # save weighted mean cc (by expected reads) for grand cc rate. 
r002 <- mean(myt$tc) # save mean for below calculation of grand cc rate. 
 
# overall cc rate
paste0("mean cross contam as % total counts = ", weighted.mean(c(cc001, cc002), c(r001, r002)), " %") # weighted mean contam weighted.mean(c(contam rate poc, contam rate faevo), c(total counts poc, total counts faevo))
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx2 <- myt$cc
myr <- myt$tc
myc <- setpalette[1]

mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Mean Barcode Contamination Rate (Percent Total Counts)"

myhighlight <- "black"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mytextsize <- 8
myheight <- 7
mywidth <- 7

p_b <- ggplot(myt, aes(x=myx2)) +
  geom_histogram(alpha = myfillapha ,color = myc, fill = myc,  binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx2, myr, na.rm = T), linetype = "dashed", color = myhighlight) +
  geom_rug(color = myc, alpha = myptalpha)+
  xlim(NA, 1.0) +
  theme_classic() +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  geom_hline(yintercept=-0.01, colour="white", size=1.01)+
  annotate("text", x = 1, y = 50, label = "B", size = 10)
p_b
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
#pdf(file = "000_Figure_S1_b.pdf", width = mywidth, height = myheight); p; dev.off()  # 2columns wide, half as tall
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
grid.arrange(p_a, p_b, nrow = 2)
# pdf(file = "000_Figure_S1.pdf", width = mywidth, height = myheight); grid.arrange(p_a, p_b, nrow = 2); dev.off() # 2columns wide, half as tall
pdf(file = "000_Additional_File_7.pdf", width = mywidth, height = myheight); grid.arrange(p_a, p_b, nrow = 2); dev.off() # 2columns wide, half as tall

# -----------------------------------------------------------------------------
rm(cc, myt, p_a, p_b, cc001, cc002, r001, r002, myx2) # remove the temporary variable
```
<br/><br/>



Analysis: Assess change in barcode cross-contamination rate for samples from the 250-generation experiment that were resequenced.
```{r}
# Calculations & models -------------------------------------------------------
faevo.1.ce <- faevo.1.ce[,(colnames(faevo.1.ce) %in% colnames(faevo.2.ce))] # subset the run 1 data to only include those columns in the rerun dataset..expected counts..
faevo.1.cc <- faevo.1.cc[,(colnames(faevo.1.cc) %in% colnames(faevo.2.cc))] # cross contamination counts
faevo.1.ce <- faevo.1.ce[,colnames(faevo.1.ce)]; faevo.1.cc <- faevo.1.cc[,colnames(faevo.1.ce)] # reorder the run 1 data by column name
faevo.2.ce <- faevo.2.ce[,colnames(faevo.1.ce)]; faevo.2.cc <- faevo.2.cc[,colnames(faevo.1.ce)] # reorder the run 2 data by run 1 column name (for paired t test below)
myt1 <- ((colSums(faevo.1.cc, na.rm = T)) / (colSums(faevo.1.ce, na.rm = T) + colSums(faevo.1.cc, na.rm = T))) / colSums(!is.na(faevo.1.cc)) # cross contam run 1 
myt2 <- ((colSums(faevo.2.cc, na.rm = T)) / (colSums(faevo.2.ce, na.rm = T) + colSums(faevo.2.cc, na.rm = T))) / colSums(!is.na(faevo.2.cc)) # cross contam run 2
myt1r <- (colSums(faevo.1.ce, na.rm = T) +  colSums(faevo.1.cc, na.rm = T)) # reads run 1
myt2r  <- (colSums(faevo.2.ce, na.rm = T) +  colSums(faevo.2.cc, na.rm = T)) # reads run 2

# unweighted t-test results match weighted t-test qualitatively. see weighted t.test imemediately below.
# var.test(myt1, myt2) # variance is not equal
# mymod <- t.test(myt1, myt2, alternative = "greater", paired = TRUE, var.equal = FALSE); mymod # t.test, paired, 1 sided (greater), unequal variance 

myt <- myt1 - myt2 # calculatation for weighted t.test below (contam run 1 - contam run 2)
mytr <- 2/ ((1/myt1r) + (1/myt2r)) # reads for calculation below (harmonic mean of reads for run 1 and run 2)
mymod2 <- wtd.t.test(x = myt, y = 0, weight = mytr, alternative = "greater", mean1 = T) # t.test, paired, 1 sided (greater), weighted
# -----------------------------------------------------------------------------

# create temporary plotting dataframe -----------------------------------------
myt1 <- as.data.frame(cbind(myt1, myt1r)); colnames(myt1) <- c("cc", "r"); myt1$seq.run <- 1 # run 1 df
myt2 <- as.data.frame(cbind(myt2, myt2r)); colnames(myt2) <- c("cc", "r"); myt2$seq.run <- 2 # run 2 df
myt <- rbind(myt1, myt2); myt$seq.run <- as.factor(myt$seq.run) # combine
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- myt$seq.run
myy <- myt$cc
myr <- myt$r

myx1 <- myt1$cc
myr1 <- myt1$r

myx2 <- myt2$cc
myr2 <- myt2$r

mytitle <-NULL
myylab <- "Mean Barcode Contamination Rate (% Total Counts)"
myxlab <- "Sequenced Libary Run Number"

myoutline <-  "grey50"
myfill <-  "grey90"
myhighlight <- "grey50"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 7
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(myt, aes(x=myx, y=myy, weight = myr, color = myx)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_segment(x=0.75, xend=1.25, y = weighted.mean(myx1, myr1),  yend = weighted.mean(myx1, myr1), color = myhighlight) +
  geom_segment(x=1.75, xend=2.25, y = weighted.mean(myx2, myr2),  yend = weighted.mean(myx2, myr2), color = myhighlight) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_rug(sides="l", alpha = myptalpha)+
  scale_color_manual(values = mypalette)+
  geom_hline(yintercept = 0, lty = "dotted") + 
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab) +
  scale_x_discrete(breaks=c("1","2"), labels=c("Library 1", "Library 2"))+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S2.pdf", width = mywidth, height = myheight); p; dev.off()  # 7by7
pdf(file = "000_Additional_File_8.pdf", width = mywidth, height = myheight); p; dev.off()  # 7by7

# -----------------------------------------------------------------------------
rm(faevo.1.ce, faevo.1.cc, faevo.2.ce, faevo.2.cc, myt1, myt1r, myt2, myt2r, myt, mytr, p) # clean up this section. 
rm(faevo.cc, faevo.ce, poc.cc, poc.ce) # clean up for next major set of analyses (remove the counts datasets to keep our global environment clean)
```
<br/><br/>


Analysis: Assess fitness change in 250-generations of experimental evolution for barcodes in the 250-generation experiment. 
```{r}
my <- myfa[order(myfa$bctID),]
# model & diagnostic plots ----------------------------------------------------
mymod <- lm(deltafit ~ bctID + 0, weights = rdeltafit, data = my);summary(mymod)
hist(residuals(mymod), breaks = 100) # tails do look a little heavy
hist(expand_residuals(mymod, my$rdeltafit), breaks = 100) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # model fit (multi) -- looks pretty good. 
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S10.html") # table does not have corrected p-values. 
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_12.html") # table does not have corrected p-values. 
# -----------------------------------------------------------------------------

# create results dataframe ----------------------------------------------------
myres <- as.data.frame(coef(summary(mymod)), stringsAsFactors = F)
myres$p1s_l <- pt(coef(summary(mymod))[, 3], mymod$df, lower = T) # one-sided test p-values for lower
myres$p1s_h <- pt(coef(summary(mymod))[, 3], mymod$df, lower = F) # one-sided test p-values for higher
myres$p1s_l.adj <- p.adjust(myres$p1s_l, method = "fdr") # fdr adjusted p value (for 1-sided lower)
myres$p1s_h.adj <- p.adjust(myres$p1s_h, method = "fdr") # fdr adjusted p value (for 1-sided higher)
myres$bcid <-  gsub("^.*?D","",rownames(myres)) # fix barcode id names
myres$m_deltafit <- ddply(my, ~bctID, function(my) weighted.mean(my$deltafit, my$rdeltafit))[,2]
myres$m_rdeltafit <- ddply(my, ~bctID, function(my) mean(my$rdeltafit))[,2]
myres$mcm_deltafit <- myres$m_deltafit - weighted.mean(myres$m_deltafit, myres$m_rdeltafit)

# NEW NEW NEW
myres$se_deltafit <- ddply(my, ~bctID, function(my) sjstats::se(my$deltafit))[,2]
# NEW NEW NEW
 
myres$color <- "fdr > 0.01"; myres$color[myres$p1s_h.adj <= 0.01] <- "fdr <= 0.01"
myres$color <- as.factor(myres$color); myres$color <- relevel(myres$color, "fdr > 0.01")
myres$treatment <- gsub('0025d', '0025', gsub('001d', '001', gsub('.{4}$', '', myres$bcid))) # strip bc id from treatment label, store in myres
# -----------------------------------------------------------------------------

# review results --------------------------------------------------------------
paste0("weighted mean fitness increase for increasers = ",weighted.mean(myres$m_deltafit[myres$p1s_h.adj <= 0.01], myres$m_rdeltafit[myres$p1s_h.adj <= 0.01])) # weighted mean fit inc of sig increasers only
paste0("minimum fitness increase for increasers = ", min(myres$m_deltafit[myres$p1s_h.adj <= 0.01])) # minimum significant increase of 2.4%
paste0("maximum fitness increase for increasers = ", max(myres$m_deltafit[myres$p1s_h.adj <= 0.01]))# maximum significant increase of 23.5%

# all treatments together
paste0("Number of barcodes with significant decreases in fitness = ", nrow(myres[myres$p1s_l.adj <= 0.01, ]))  # check for significant fitness decrease: # find none
paste0("Number of barcodes with significant increases in fitness = ", nrow(myres[myres$p1s_h.adj <= 0.01, ]))  # check for significant fitness increase: # find 35 rows. (35 increasers out of 152)
paste0("Proportion of barcodes with significant increases in fitness = ",nrow(myres[myres$p1s_h.adj <= 0.01, ])/nrow(myres)) # prop increasers  # 0.23

# CM diploid 1:1000
paste0("CM diploid 1:1000:")
myrest <- myres[myres$treatment == "CMdiploid0.001",]; paste0("n barcodes in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM haploid 1:1000
paste0("CM haploid 1:1000:")
myrest <- myres[myres$treatment == "CMhaploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM+salt diploid 1:1000
paste0("CM+salt diploid 1:1000:")
myrest <- myres[myres$treatment == "CM+Saltdiploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM+ethanol diploid 1:1000
paste0("CM+ethanol diploid 1:1000:")
myrest <- myres[myres$treatment == "CM+Ethanoldiploid0.001",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM diploid 1:250
paste0("CM diploid 1:250:")
myrest <- myres[myres$treatment == "CMdiploid0.004",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))

# CM diploid 1:4000
paste0("CM diploid 1:4000:")
myrest <- myres[myres$treatment == "CMdiploid0.00025",]; paste0("n entries in treatment = ", nrow(myrest))
paste0("n barcodes with fitness increase in treatment = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ]))
paste0("proportion of barcodes in treatment that increased in fitness = ", nrow(myrest[myrest$p1s_h.adj <= 0.01, ])/nrow(myrest))
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
# Plot ONLY data with se_deltafit < 0.029 for clarity -- This removes high SE points that have a large mean fitness increase, but have SE such that this fit increase is non-significant.
myx <- myres[myres$se_deltafit < 0.029,]$m_deltafit
myr <- myres[myres$se_deltafit < 0.029,]$m_rdeltafit
myc <- myres[myres$se_deltafit < 0.029,]$color
mybinwidth <- 0.01

mytitle <- NULL
myylab <- "Count"
myxlab <- "Fitness change"

myhighlight1 <- "black"
myhighlight2 <- setpalette[1]
myhighlight3 <- setpalette[2]
myfillapha <- 0.25
myptalpha <- 0.35
mylinealpha <- 0.35
mypalette <- setpalette

mytextsize <- 8
myheight <- 3.345
mywidth <- 3.345


# p <- ggplot(myres, aes(x=myx, color = myc, fill = myc)) + 
p <- ggplot(myres[myres$se_deltafit < 0.029,], aes(x=myx, color = myc, fill = myc)) + 
  geom_histogram(alpha = myfillapha, position = "identity", binwidth = mybinwidth) +
  geom_vline(xintercept = weighted.mean(myx, myr), linetype = "dashed", color = myhighlight) +
  geom_vline(xintercept = weighted.mean(myx[myc == "fdr > 0.01"], myr[myc == "fdr > 0.01"]), linetype = "dashed", color = myhighlight2) +
  geom_vline(xintercept = weighted.mean(myx[myc == "fdr <= 0.01"], myr[myc== "fdr <= 0.01"]), linetype = "dashed", color = myhighlight3) +
  geom_rug(alpha = myptalpha)+
  scale_color_manual(values =mypalette, guide = FALSE) + 
  scale_fill_manual(values =mypalette) +
  theme_classic() +
  theme(legend.position= c(0.8,0.8)) +
  labs(fill = "Significance") +
  ggtitle(mytitle)+ ylab(myylab)+ xlab(myxlab) +
  geom_hline(yintercept=0.01, colour="white", size=1.01)+
  theme(axis.title.y = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = mytextsize, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = mytextsize, angle = 0))+
  theme(axis.text.x = element_text(size = mytextsize, angle = 0))+
  theme(legend.title = element_text(size = mytextsize, face = "bold"))+
  theme(legend.text = element_text(size = mytextsize))+
  scale_x_continuous(breaks = seq(-0.1,0.25,by=0.05),
                     labels = c("-0.1", "-0.05", "0", "0.05", "0.1", "0.15", "0.2", "0.25"),
                     limits = c(-0.05, 0.25))+
  scale_y_continuous(breaks = seq(0,25,by=5),
                     limits = c(0,25))
p
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_4.pdf", width = mywidth, height = myheight); p; dev.off() # 7by7
# -----------------------------------------------------------------------------
rm(my, mymod, myres, myrest, p)
```
<br/><br/>


Analysis: Characterization of error and contribution of covariates to SE deltafitness and deltafitness.
1: Build the dataframe to test SE delatfitness
```{R}
my <- myfa # get a copy of the main data to work on. 
# split by replicate and bind to form a wide frame.
my1 <- my[my$rep == 1,] # r1
my2 <- my[my$rep == 2,]; colnames(my2) <- paste0(colnames(my2), "_2") # r2
my3 <- my[my$rep == 3,]; colnames(my3) <- paste0(colnames(my3), "_3") # r3
my4 <- my[my$rep == 4,]; colnames(my4) <- paste0(colnames(my4), "_4") # r4
# sum(my1$bc1 != my2$bc1_2) # sort order matches.
my <- cbind(my1, my2, my3, my4) # bind

my$sedeltafit <- apply(cbind(my$deltafit, my$deltafit_2, my$deltafit_3, my$deltafit_4), 1, sjstats::se) # calculate SE deltafit among replicates
  
my$medcount <- apply(cbind(my$bc1cts_i_0r1,my$bc1cts_i_0r2,my$bc1cts_i_0r3,my$bc1cts_i_0r4,
                  my$bc1cts_f_0r1, my$bc1cts_f_0r2, my$bc1cts_f_0r3, my$bc1cts_f_0r4,
                  my$bc1cts_i, my$bc1cts_i_2, my$bc1cts_i_3, my$bc1cts_i_4,
                  my$bc1cts_f, my$bc1cts_f_2, my$bc1cts_f_3, my$bc1cts_f_4),
                  1, median, na.rm = T) # calculate median counts for each SE deltafit entry.

# Calculate BC proportions for next step @ all timepoints for all replicates.
my$prop_i_0r1 <- my$bc1cts_i_0r1 / (my$bc1cts_i_0r1 + my$bc2cts_i_0r1)
my$prop_i_0r2 <- my$bc1cts_i_0r2 / (my$bc1cts_i_0r2 + my$bc2cts_i_0r2)
my$prop_i_0r3 <- my$bc1cts_i_0r3 / (my$bc1cts_i_0r3 + my$bc2cts_i_0r3)
my$prop_i_0r4 <- my$bc1cts_i_0r4 / (my$bc1cts_i_0r4 + my$bc2cts_i_0r4)

my$prop_f_0r1 <- my$bc1cts_f_0r1 / (my$bc1cts_f_0r1 + my$bc2cts_f_0r1)
my$prop_f_0r2 <- my$bc1cts_f_0r2 / (my$bc1cts_f_0r2 + my$bc2cts_f_0r2)
my$prop_f_0r3 <- my$bc1cts_f_0r3 / (my$bc1cts_f_0r3 + my$bc2cts_f_0r3)
my$prop_f_0r4 <- my$bc1cts_f_0r4 / (my$bc1cts_f_0r4 + my$bc2cts_f_0r4)

my$prop_i_250r1 <- my$bc1cts_i / (my$bc1cts_i + my$bc2cts_i)
my$prop_i_250r2 <- my$bc1cts_i_2 / (my$bc1cts_i_2 + my$bc2cts_i_2)
my$prop_i_250r3 <- my$bc1cts_i_3 / (my$bc1cts_i_3 + my$bc2cts_i_3)
my$prop_i_250r4 <- my$bc1cts_i_4 / (my$bc1cts_i_4 + my$bc2cts_i_4)

my$prop_f_250r1 <- my$bc1cts_f / (my$bc1cts_f + my$bc2cts_f)
my$prop_f_250r2 <- my$bc1cts_f_2 / (my$bc1cts_f_2 + my$bc2cts_f_2)
my$prop_f_250r3 <- my$bc1cts_f_3 / (my$bc1cts_f_3 + my$bc2cts_f_3)
my$prop_f_250r4 <- my$bc1cts_f_4 / (my$bc1cts_f_4 + my$bc2cts_f_4)


my$medprop <- apply(cbind(my$prop_i_0r1,my$prop_i_0r2,my$prop_i_0r3,my$prop_i_0r4,
                  my$prop_f_0r1, my$prop_f_0r2, my$prop_f_0r3, my$prop_f_0r4,
                  my$prop_i_250r1, my$prop_i_250r2, my$prop_i_250r3, my$prop_i_250r4,
                  my$prop_f_250r1, my$prop_f_250r2, my$prop_f_250r3, my$prop_f_250r4),
                  1, median, na.rm = T) # calculate median proportion for each SE deltafit entry

my$mnfit0 <- NA # Calculate the weighted mean generation 0 fitness for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnfit0[i] <- weighted.mean(my[i,c("fit0r1", "fit0r2", "fit0r3", "fit0r4")],
                                    my[i,c("rfit0r1", "rfit0r2", "rfit0r3", "rfit0r4")], na.rm = T)
}

my$mnfit250 <- NA # Calculate the weighted mean generation 250 fitness for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnfit250[i] <- weighted.mean(my[i,c("fit25", "fit25_2", "fit25_3", "fit25_4")],
                                    my[i,c("rfit25", "rfit25_2", "rfit25_3", "rfit25_4")], na.rm = T)
}


# NOT USED IN MODEL-- captures same data as fit0 + fit250
my$mndeltafit <- NA
for(i in 1:nrow(my)){
  my$mndeltafit[i] <- weighted.mean(my[i,c("deltafit", "deltafit_2", "deltafit_3", "deltafit_4")],
                                    my[i,c("rdeltafit", "rdeltafit_2", "rdeltafit_3", "rdeltafit_4")], na.rm = T)
}

my$mnccdeltafit <- NA # Calculate the weighted mean cross contamination rate for each SE deltafitness entry 
for(i in 1:nrow(my)){
  my$mnccdeltafit[i] <- weighted.mean(my[i,c("ccdeltafit", "ccdeltafit_2", "ccdeltafit_3", "ccdeltafit_4")],
                                    my[i,c("rdeltafit", "rdeltafit_2", "rdeltafit_3", "rdeltafit_4")], na.rm = T)
}

my$mnrdeltafit <- apply(cbind(my$rdeltafit, my$rdeltafit_2, my$rdeltafit_3, my$rdeltafit_4),
                       1, mean, na.rm = T) # calculate an updated "sampling effort" value for each SE deltafitness entry 

myfa_w <- my
```


2: Assess variables that affect SE deltafitness: using sequential term removal via p-value
```{R}
mymod <- lm(I(scale(my$sedeltafit)) ~ I(scale(my$mnccdeltafit)) +I(scale(my$mndeltafit)) +I(scale(my$medcount)) +I(scale(my$medprop)) + my$treatment, weights = my$mnrdeltafit)
car::vif(mymod) # VIF looks okay.
summary(mymod)

# model output -----------------------------------------------------------------=
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Table_S9.html") # r2 on the lm version of htis model is 
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Additional_File_11.html") # r2 on the lm version of htis model is 
# -----------------------------------------------------------------------------

```


3: Assess variables that affect SE deltafitness: using model selection and multimodel inference
```{R}
# mymod <- lm(I(scale(my$sedeltafit)) ~ I(scale(my$mnccdeltafit)) +I(scale(my$mndeltafit)) +I(scale(my$medcount)) +I(scale(my$medprop))+ my$treatment, weights = my$mnrdeltafit, na.action = "na.fail")
# summary(mymod)
# 
# mymod1 <- dredge(mymod)
# 
# # model averaging using delata AIC <= 4
# avgmod.delta4 <- model.avg(object = mymod1, subset = delta <= 4)
# summary(avgmod.delta4)
# importance(avgmod.delta4)
# confint(avgmod.delta4)
# 
# # model averaging using cumulative sum weights .95 (include models until you get a sum weight of .95)
# avgmod.95p <- model.avg(mymod1, cumsum(weight) <= .95)
# summary(avgmod.95p)
# importance(avgmod.95p)
# confint(avgmod.95p)
```

4: Build the dataframe to test delatfitness
```{R}
my3 <- myfa[order(myfa$bctID),]

my3$mncount0i <- NA
my3$mncount0f <- NA
for(i in 1:nrow(my3)){
  my3$mncount0i[i] <- weighted.mean(my3[i,c("bc1cts_i_0r1", "bc1cts_i_0r2", "bc1cts_i_0r3", "bc1cts_i_0r4")],
                                    my3[i,c("r0ir1", "r0ir2", "r0ir3", "r0ir4")], na.rm = T)
  my3$mncount0f[i] <- weighted.mean(my3[i,c("bc1cts_f_0r1", "bc1cts_f_0r2", "bc1cts_f_0r3", "bc1cts_f_0r4")],
                                    my3[i,c("r0fr1", "r0fr2", "r0fr3", "r0fr4")], na.rm = T)
}
my3$medcount <- apply(cbind(my3$mncount0i, my3$mncount0f, my3$bc1cts_i, my3$bc1cts_f),
                  1, median, na.rm = T)


my3$prop_i_0r1 <- my3$bc1cts_i_0r1 / (my3$bc1cts_i_0r1 + my3$bc2cts_i_0r1)
my3$prop_i_0r2 <- my3$bc1cts_i_0r2 / (my3$bc1cts_i_0r2 + my3$bc2cts_i_0r2)
my3$prop_i_0r3 <- my3$bc1cts_i_0r3 / (my3$bc1cts_i_0r3 + my3$bc2cts_i_0r3)
my3$prop_i_0r4 <- my3$bc1cts_i_0r4 / (my3$bc1cts_i_0r4 + my3$bc2cts_i_0r4)

my3$prop_f_0r1 <- my3$bc1cts_f_0r1 / (my3$bc1cts_f_0r1 + my3$bc2cts_f_0r1)
my3$prop_f_0r2 <- my3$bc1cts_f_0r2 / (my3$bc1cts_f_0r2 + my3$bc2cts_f_0r2)
my3$prop_f_0r3 <- my3$bc1cts_f_0r3 / (my3$bc1cts_f_0r3 + my3$bc2cts_f_0r3)
my3$prop_f_0r4 <- my3$bc1cts_f_0r4 / (my3$bc1cts_f_0r4 + my3$bc2cts_f_0r4)

my3$prop_i_250r1 <- my3$bc1cts_i / (my3$bc1cts_i + my3$bc2cts_i)
my3$prop_f_250r1 <- my3$bc1cts_f / (my3$bc1cts_f + my3$bc2cts_f)

my3$mnprop0i <- NA
my3$mnprop0f <- NA
for(i in 1:nrow(my3)){
  my3$mnprop0i[i] <- weighted.mean(my3[i,c("prop_i_0r1", "prop_i_0r2", "prop_i_0r3", "prop_i_0r4")],
                                    my3[i,c("r0ir1", "r0ir2", "r0ir3", "r0ir4")], na.rm = T)
  my3$mnprop0f[i] <- weighted.mean(my3[i,c("prop_f_0r1", "prop_f_0r2", "prop_f_0r3", "prop_f_0r4")],
                                    my3[i,c("r0fr1", "r0fr2", "r0fr3", "r0fr4")], na.rm = T)
}
my3$medprop <- apply(cbind(my3$mnprop0i, my3$mnprop0f, my3$prop_i_250r1, my3$prop_f_250r1),
                  1, median, na.rm = T)
```

5: Assess variables that affect deltafitness
```{R}
mymod <- lmer(I(scale(deltafit)) ~ I(scale(ccdeltafit)) +treatment +(1|bctID), weights = rdeltafit, data = my3, control=lmerControl(optimizer ="bobyqa",optCtrl=list(maxfun=2e4)))
anova(mymod)
summary(mymod) # final model
AIC(mymod)
```

6: Assess variables that affect deltafitness: using model selection and multimodel inference
```{R}
# mymod <- lmer(I(scale(deltafit)) ~ I(scale(ccdeltafit)) +I(scale(fit0)) +I(scale(medcount)) +I(scale(medprop)) +treatment +(1|bctID), weights = rdeltafit, data = my3, control=lmerControl(optimizer ="bobyqa",optCtrl=list(maxfun=2e4)), na.action = "na.fail")
# summary(mymod)
# 
# mymod1 <- dredge(mymod)
# 
# # model averaging using delata AIC <= 4
# avgmod.delta4 <- model.avg(object = mymod1, subset = delta <= 4)
# summary(avgmod.delta4)
# importance(avgmod.delta4)
# confint(avgmod.delta4)
# 
# # model averaging using cumulative sum weights .95 (include models until you get a sum weight of .95)
# avgmod.95p <- model.avg(mymod1, cumsum(weight) <= .95)
# summary(avgmod.95p)
# importance(avgmod.95p)
# confint(avgmod.95p)
```


Analysis: Power ( quick look at #'s)
```{r}
# POC FIT ASSAY -- FITNESS EQUIVALENCE -----------------------------------------
my <- poc92[order(poc92$bcid),]
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected ~ my$bcid + 0, weights = my$r); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~1.76 fitness change 
myeffectsize <- 1/myrmse # effect size of 1 is a 1.76 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse


# 250 GEN EXP -- FITNESS EQUIVALENCE -------------------------------------------
colnames(myfa)
myfa_0 <- myfa
my1 <- myfa_0[, c("rep","bc1", "bctID", "fit0r1", "rfit0r1"),]; my1 <- my1[my1$rep == 1,]
my2 <- myfa_0[, c("rep","bc1", "bctID", "fit0r2", "rfit0r2"),]; my2 <- my2[my2$rep == 2,]
my3 <- myfa_0[, c("rep","bc1", "bctID", "fit0r3", "rfit0r3"),]; my3 <- my3[my3$rep == 3,]
my4 <- myfa_0[, c("rep","bc1", "bctID", "fit0r4", "rfit0r4"),]; my4 <- my4[my4$rep == 4,]
colnames(my1) <- c("rep", "bc1", "bctID", "fit0", "rfit0")
colnames(my2) <- c("rep", "bc1", "bctID", "fit0", "rfit0")
colnames(my3) <- c("rep", "bc1", "bctID", "fit0", "rfit0")
colnames(my4) <- c("rep", "bc1", "bctID", "fit0", "rfit0")
myfa_0 <- rbind(my1, my2, my3, my4)
my <- myfa_0
my$bc1 <- as.factor(my$bc1); my$bctID <- as.factor(my$bctID)

# Same as poc version --------------------------------------
my$fit0_c <- my$fit0 - weighted.mean(my$fit0, my$rfit0)
mymod <- lm(my$fit0_c~ my$bc1 + 0, weights = my$rfit0); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~3.22 fitness dif 
myeffectsize <- 1/myrmse # effect size of 1 is a 3.22 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treat effects
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 95.1% power to detect treatment fitness differences of 1.00%

# split by bctID, rather than just BC to get 4 per. --------
my$fit0_c <- my$fit0 - weighted.mean(my$fit0, my$rfit0)
mymod <- lm(my$fit0_c~ my$bctID + 0, weights = my$rfit0); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~2.92 fitness dif 
myeffectsize <- 1/myrmse # effect size of 1 is a 2.92 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treat effects
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 96.6% power to detect treatment fitness differences of 1.00%




# 250 GEN EXP -- USING DELTA FIT -----------------------------------------------
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$deltafit ~ my$bctID + 0, weights = my$rdeltafit); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.307 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.307 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treat effects
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 87.7% power to detect treatment fitness differences of 1.00%

# 250 GEN EXP -- USING FIT 250 -------------------------------------------------
my <- myfa[order(myfa$bctID),]
mymod <- lm(my$fit25 ~ my$bctID + 0, weights = my$rfit25); summary(mymod)
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~4.34 fitness dif
myeffectsize <- 1/myrmse # effect size of 1 is a 4.34 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treat effects
pow <- pwr.f2.test(u= 1, v= ((22*2) -1 - 1), f2=myeffectsize, sig.level = 0.05)
pow$power # 87.5% power to detect treatment fitness differences of 1.00%




# now some power calculations for fitness difference detection by barcode  --------------------------------------------------
# 1. Power to detect fitness divergence (from self or from reference, same math -- so works for fitness divergence from ancestor (init fit) and fitness change)
#   a. POC data -- These are t-tests, so the pwr calc needs psd, not rmse (discuss with JF)
#   b. 250 gen exp -- These are t-tests, so the pwr calc needs psd, not rmse (discuss with JF)

# 1. a
my <- poc92
my1 <- my[my$exp == 1,]; colnames(my1) <- paste0(colnames(my1), "_R1")
my2 <- my[my$exp == 2,]; colnames(my2) <- paste0(colnames(my2), "_R2")
my3 <- my[my$exp == 3,]; colnames(my3) <- paste0(colnames(my3), "_R3")
my4 <- my[my$exp == 4,]; colnames(my4) <- paste0(colnames(my4), "_R4")
my5 <- my[my$exp == 5,]; colnames(my5) <- paste0(colnames(my5), "_R5")
my6 <- my[my$exp == 6,]; colnames(my6) <- paste0(colnames(my6), "_R6")
my7 <- my[my$exp == 7,]; colnames(my7) <- paste0(colnames(my7), "_R7")
my8 <- my[my$exp == 8,]; colnames(my8) <- paste0(colnames(my8), "_R8")
my9 <- my[my$exp == 9,]; colnames(my9) <- paste0(colnames(my9), "_R9")
my10 <- my[my$exp == 10,]; colnames(my10) <- paste0(colnames(my10), "_R10")
poc92_w <- cbind(my1, my2, my3, my4, my5, my6, my7, my8, my9, my10)

for(i in 1:nrow(poc92_w)){
  poc92_w$mnrw[i] <- weighted.mean(poc92_w[i,c("rw_R1", "rw_R2", "rw_R3", "rw_R4", "rw_R5", "rw_R6", "rw_R7", "rw_R8", "rw_R9", "rw_R10")],
                                    poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
  poc92_w$mnr[i] <- rowMeans(poc92_w[i,c("r_R1", "r_R2", "r_R3", "r_R4", "r_R5", "r_R6", "r_R7", "r_R8", "r_R9", "r_R10")], na.rm = T)
}

my <- poc92_w
my$psd_r1 <- ((my$rw_R1-my$mnrw)^2)/10
my$psd_r2 <- ((my$rw_R2-my$mnrw)^2)/10
my$psd_r3 <- ((my$rw_R3-my$mnrw)^2)/10
my$psd_r4 <- ((my$rw_R4-my$mnrw)^2)/10
my$psd_r5 <- ((my$rw_R5-my$mnrw)^2)/10
my$psd_r6 <- ((my$rw_R6-my$mnrw)^2)/10
my$psd_r7 <- ((my$rw_R7-my$mnrw)^2)/10
my$psd_r8 <- ((my$rw_R8-my$mnrw)^2)/10
my$psd_r9 <- ((my$rw_R9-my$mnrw)^2)/10
my$psd_r10 <- ((my$rw_R10-my$mnrw)^2)/10
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4, my$psd_r5, my$psd_r6, my$psd_r7, my$psd_r8, my$psd_r9, my$psd_r10), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnr, na.rm = T)

pow <- pwr.t.test(d= 0.01 / psd, n=4, sig.level = 0.05)
pow$power # 67% power to detect 1% fit change. 

pow <- pwr.t.test(power = 0.8, n=4, sig.level = 0.05)
pow$d*psd # 80% power to detect ~1.2% fitness difference


# 1. b
# power to detect fitness increase / decrease (t-tests) --------------------------------------------
# d = m1 - m2 / q; m1 is mean group 1, m2 is mean group 2, q is common standard deviation in the two groups
# here m1 is change in fitness and m2 is 0. mean q is used and is the weighted mean of all
# population standard deviation of the four replicate sets in each row of the dataset.

# get data and ccalculate d -----------
my <- myfa_w
my$psd_r1 <- ((my$deltafit-my$mndeltafit)^2)/4
my$psd_r2 <- ((my$deltafit_2-my$mndeltafit)^2)/4
my$psd_r3 <- ((my$deltafit_3-my$mndeltafit)^2)/4
my$psd_r4 <- ((my$deltafit_4-my$mndeltafit)^2)/4
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnrdeltafit, na.rm = T)

pow <- pwr.t.test(d= 0.01 / psd, n=4, sig.level = 0.05)
pow # 16% power to detect 1% fit change. 

pow <- pwr.t.test(power = 0.8, n=4, sig.level = 0.05)
pow$d*psd # 80% power to detect ~3% fitness change

```




Analysis: Assess power to detect fitness change in this experimental evolution system, given replicate variance in the POC fitness assay dataset. 
```{r}
# run the appropriate model (fit equivalence model from above -- telling us ability to measure fit for each bcid based on our 10 replicates.)
my <- poc92[order(poc92$bcid),]
my$rw_corrected <- my$rw - weighted.mean(my$rw, my$r)
mymod <- lm(my$rw_corrected~ my$bcid + 0, weights = my$r); summary(mymod)

# calculate rmse -------------------------------------------------
myrmse <-sqrt(mean(residuals(mymod)^2))*100 # this is the rmse from the fitness equivalence model*100 --> effect size of 1 corresonds to an ~1.76 fitness change 
myeffectsize <- 1/myrmse # effect size of 1 is a 1.76 fitnesss change, so for a fitness change of 1.00, expect effect size of 1/myrmse

# power to detect treatment effects ------------------------------
myv <- (22*2) -1 - 1
mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = myeffectsize, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 
# mypowersize <- (pwr.f2.test(u = 1, v=myv, f2 = 0.5, sig.level = 0.05))$power # powersize for plotting below, where 22 is the number of BCs in any given treatment. 

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=100, ncol = 5); colnames(mypower) <- c("u", "v", "power", "f2", "sig.level")
mypower <- as.data.frame(mypower)
mypower$u <- 1
mypower$v <- c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1)
mypower$power <- NA
mypower$f2 <- c(rep(myeffectsize*2,10), rep(myeffectsize*1.75,10), rep(myeffectsize*1.5,10),
                rep(myeffectsize*1.25,10), rep(myeffectsize*1,10), rep(myeffectsize*.75,10), 
                rep(myeffectsize*.5,10), rep(myeffectsize*.25,10),  rep(myeffectsize*.1,10),  rep(myeffectsize*.05,10))
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,10), rep(2,10), rep(3,10), rep(4,10), rep(5,10), rep(6,10), rep(7,10), rep(8,10), rep(9,10), rep(10,10))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.f2.test(u=mypower$u[i],
                               v=mypower$v[i],
                               f2=mypower$f2[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# Plotting -------------------------------------------------
# plotting setup -----------------------
myheight <- 7
mywidth <- 7

# plot effect size x power -------------
mypower$n <- mypower$v + 2
mypower$n <- factor(mypower$n, levels =c(myv+2, (myv*0.9)+2, (myv*0.8)+2, (myv*0.7)+2, (myv*0.6)+2, (myv*0.5)+2, (myv*0.4)+2, (myv*0.3)+2, (myv*0.2)+2, (myv*0.1)+2))
mypower$v <- factor(mypower$v, levels =c(myv, myv*0.9, myv*0.8, myv*0.7, myv*0.6, myv*0.5, myv*0.4, myv*0.3, myv*0.2, myv*0.1))

p<-ggplot(mypower, aes(x=f2, y=power, group=n)) +
  geom_vline(xintercept = myeffectsize, linetype = "dashed", color = "darkgray")+
  geom_line(aes(color=n))+
  geom_point(aes(color=n))+
  geom_point(x = myeffectsize, y = mypowersize, pch = 1, size = 5, color = "darkgray")+
  theme_classic()+
  ggtitle("power to detect fitness differences between two treatments \n with n total barcodes")+
  labs(color = "n (total barcodes)")+
  scale_x_continuous(name = "Fitness Difference between Treatments", breaks = c(myeffectsize*0.05, myeffectsize*0.1, myeffectsize*0.25, 
                                                                                myeffectsize*0.5, myeffectsize*0.75, myeffectsize, 
                                                                                myeffectsize*1.25, myeffectsize*1.5, myeffectsize*1.75, myeffectsize*2), 
                     labels = c("0.05%","", "0.25%", "0.5%", "0.75%", "1.0%", "1.25%", "1.5%", "1.75%", "2.0%"))
p
pdf(file = paste("000_m_FitChangeTreatDif_PowerByRMSE_effectsizexpower.pdf"), width = mywidth, height = myheight); p; dev.off()

# plot n barcodes x power --------------
mypower$n <- as.numeric(levels(mypower$n))[mypower$n]
mypower$f2 <- factor(round(mypower$f2,2), levels = c(sort(unique(round(mypower$f2,2)), decreasing = T)))
p<-ggplot(mypower, aes(x=n, y=power, group=f2)) +
  geom_vline(xintercept = 44, linetype = "dashed", color = "darkgray")+
  geom_line(aes(color=f2))+
  geom_point(aes(color=f2))+
  geom_point(x = 44, y = mypowersize, pch = 1, size = 5, color = "darkgray")+
  theme_classic()+
  scale_x_continuous(name = "n (total barcodes)", breaks = c(4, 10, 15, 21, 27, 33, 38, 44), labels = c(4, 10, 15, 21, 27, 33, 38, 44))+
  ggtitle("power to detect fitness differences between two treatments \n with n total barcodes")+
  scale_color_discrete(name = "Fitness Difference \n between Treatments", labels = rev(c("0.05%","0.1%", "0.25%", "0.5%", "0.75%", "1.0%", "1.25%", "1.5%", "1.75%", "2.0%")))
p
pdf(file = paste("000_m_FitChangeTreatDif_PowerByRMSE_nxpower.pdf"), width = mywidth, height = myheight); p; dev.off()


# power to detect fitness increase / decrease (t-tests) --------------------------------------------
# d = m1 - m2 / q; m1 is mean group 1, m2 is mean group 2, q is common standard deviation in the two groups
# here m1 is change in fitness and m2 is 0. mean q is used and is the weighted mean of all
# population standard deviation of the four replicate sets in each row of the dataset.

# get data and conduct population sd calculation -----------
my <- myfa_w
my$psd_r1 <- (my$deltafit-my$mndeltafit)^2
my$psd_r2 <- (my$deltafit_2-my$mndeltafit)^2
my$psd_r3 <- (my$deltafit_3-my$mndeltafit)^2
my$psd_r4 <- (my$deltafit_4-my$mndeltafit)^2
my$psd_m <- rowMeans(cbind(my$psd_r1, my$psd_r2, my$psd_r3, my$psd_r4), na.rm = T)
my$psd <- sqrt(my$psd_m)
psd <- weighted.mean(my$psd, my$mnrdeltafit, na.rm = T)

# prepare plot data ----------------------------------------
mypower <- matrix(nrow=22*3, ncol = 5); colnames(mypower) <- c("fitchange", "psd", "n", "power", "sig.level")
mypower <- as.data.frame(mypower)
mypower$fitchange <- c(0.0025, 0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22)
mypower$psd <- psd
mypower$n <- c(rep(2,22), rep(3,22), rep(4,22))
mypower$power <- NA
mypower$sig.level <- 0.05
mypower$group <- c(rep(1,22), rep(2,22), rep(3,22))
mypower$group <- as.factor(mypower$group)
for(i in 1:nrow(mypower)){
  pow <- pwr.t.test(d=mypower$fitchange[i] / mypower$psd[i],
                               n=mypower$n[i],
                               sig.level = mypower$sig.level[i])
  mypower$power[i] <- pow$power
}

# Plotting -------------------------------------------------
# plot effect size x power -------------
mypower$n <- factor(mypower$n, levels = c(4,3,2))
p<-ggplot(mypower, aes(x=fitchange, y=power, group=n)) +
  geom_vline(xintercept = 0.01, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.025, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.1, linetype = "dashed", color = "gray")+
  geom_line(aes(color=n))+
  geom_point(aes(color=n))+
  geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  scale_x_continuous(name = "Fitness Change", breaks = c(0.01, 0.025, 0.05, 0.1, 0.15, 0.2), labels = c("1%", "2.5%", "5%", "10%", "15%", "20%"))+
  labs(color = "n (replicates \n per timepoint)")+
  theme_classic()+
  ggtitle("power to detect fitness change in 500 generations with n entries per timepoint")
p


pp<-ggplot(mypower, aes(x=fitchange, y=power, group=n)) +
  geom_vline(xintercept = 0.01, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.025, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "gray")+
  geom_vline(xintercept = 0.1, linetype = "dashed", color = "gray")+
  geom_line(aes(color=n))+
  geom_point(aes(color=n))+
  geom_point(x = 0.01, y = pwr.t.test(d = 0.01 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.025, y = pwr.t.test(d = 0.025 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.05, y = pwr.t.test(d = 0.05 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  geom_point(x = 0.1, y = pwr.t.test(d = 0.1 / psd, n = 4, sig.level = 0.05)$power, pch = 1, size = 5, color = "gray")+
  ggtitle(NULL)+ xlab(NULL)+ ylab(NULL)+
  theme_classic()+
  theme(legend.position = "none")+
  scale_x_continuous(limits = c(0, 0.05), breaks = c(0.01, 0.025, 0.05), labels = c("1%", "2.5%", "5%"))+
  theme(plot.background = element_rect(colour = "black"))
pp

ppp <- p + annotation_custom(ggplotGrob(pp), xmin = 0.125, xmax = .225, ymin = 0.025, ymax = 0.5)
ppp
pdf(file = paste("000_m_FitChangeIncDec_PowerByRMSE_effectsizexpower.pdf"), width = mywidth, height = myheight); ppp; dev.off()

# plot n replicates x power -------------
mypower$n <- as.numeric(levels(mypower$n))[mypower$n]
mypower$fitchange <- factor(mypower$fitchange, levels = c(sort(unique(mypower$fitchange), decreasing = T)))
p<-ggplot(mypower, aes(x=n, y=power, group=fitchange)) +
  geom_line(aes(color=fitchange))+
  geom_point(aes(color=fitchange))+
  scale_x_continuous(name = "n (replicates per timepoint)", breaks = c(2, 3, 4), labels = c(2, 3, 4))+
  theme_classic()+
  ggtitle("power to detect fitness change in 500 generations with n entries per timepoint")+
  scale_color_discrete(name = "Fitness Change", labels = rev(c("0.25%", "0.5%", "1%", "1.5%", "2%", "2.5%", "3%", "3.5%",
                                                               "4%", "45%", "5%", "6%", "7%", "8%", "9%", "10%", "12%", 
                                                               "14%", "16%", "18%", "20%", "22%")))
p
pdf(file = paste("000_m_FitChangeIncDec_PowerByRMSE_nxpower.pdf"), width = mywidth, height = myheight); p; dev.off()
```



Analysis: Assess effects of evoluitonary treatment on change in fitness in 250-generations of experimental evolution. 
```{r}
my <- myfa[order(myfa$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
mymod <- lmer(scale(deltafit) ~ scale(ccdeltafit) + treatment + (1|bctID), weights = rdeltafit, data = my, control=lmerControl(optimizer ="bobyqa",optCtrl=list(maxfun=2e4))); summary(mymod) # problems with convergence here...solved with an optimizer and some extra iterations.
# mymod <- lm(my$deltafit ~ my$ccdeltafit + my$treatment, weights = my$rdeltafit);r.squaredGLMM(mymod) # get the r2 for the lm version of the model if desired. 

# model output -----------------------------------------------------------------=
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Table_S11.html") # r2 on the lm version of htis model is 
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, show.r2 = F, file = "000_Additional_File_13.html") # r2 on the lm version of htis model is 
# -----------------------------------------------------------------------------


my <- myfa_w[order(myfa_w$bctID),] # placeholder dataframe
my <- my[my$sedeltafit < 0.029,]
min(my$mndeltafit)
max(my$mndeltafit)

myx <- my$treatment
myy <- my$mndeltafit
myr <- my$mnrdeltafit
myc <- my$treatment

mytitle <- NULL
myylab <- "Fitness change"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.345
mywidth <- 6.69
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 1:1000", "CM+EtOH \n Diploid \n 1:1000", "CM+NaCl \n Diploid \n 1:1000", "CM \n Diploid \n 1:4000", "CM \n Diploid \n 1:250", "CM \n Haploid \n 1:1000")) +
  scale_y_continuous(breaks = seq(-.05,.25,by=.05),
                     labels = c("-0.05", "0", "0.05", "0.1", "0.15", "0.2", "0.25"),
                     limits = c(-.05, .25))+
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(2,3,4,5,6), y=c(.065,.25,.045,.095,.115), label = c("**", "***", "", "***", "*"), size = 8, fontface = "bold")
  
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
pdf(file = "000_Figure_5.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, weights)
```
<br/><br/>



Analysis: Calculate fixation rate summaries by treatment for the 250-generation experiment. 
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# Review Results --------------------------------------------------------------
# my[my$fixed == T,] # these are the fixed wells
# my$treatment[my$fixed == T] # these are the treatments of the fixed wells

paste0("proportion of wells that attained fixation (n=76 total wells)= ", nrow(my[my$fixed == T,])/nrow(my))  # prop fixed

# CM diploid 1:1000
myt <- my[my$treatment == "CMdiploid0.001",]; paste0("n wells in CMdiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM haploid 1:1000
myt <- my[my$treatment == "CMhaploid0.001",]; paste0("n wells in CMhaploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM+Salt diploid 1:1000
myt <- my[my$treatment == "CM+Saltdiploid0.001",]; paste0("n wells in CM+Saltdiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM+Ethanol 1:1000
myt <- my[my$treatment == "CM+Ethanoldiploid0.001",]; paste0("n wells in CM+Ethanoldiploid0.001 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM diploid 1:250
myt <- my[my$treatment == "CMdiploid0.004",]; paste0("n wells in CMdiploid0.004 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed

# CM diploid 1:4000
myt <- my[my$treatment == "CMdiploid0.00025",]; paste0("n wells in CMdiploid0.00025 = ",nrow(myt)) #  wells
paste0("number of fixed wells in treatment = ",nrow(myt[myt$fixed,])) # number fixed
paste0("proportion of fixed wells in treatment = ",nrow(myt[myt$fixed,])/nrow(myt)) # prop fixed
# -----------------------------------------------------------------------------
rm(my, myt)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX (generation of maximum deviation from generation-0 barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxdev ~ my$treatment + my$ccmaxdev_t0 + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tmaxdev ~ my$treatment + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tmaxdev ~ my$treatment + my$ccmaxdev, weights = my$rmaxdev); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxdev ~ my$treatment, weights = my$rmaxdev); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxdev), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S12.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_14.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxdev
myr <- my$rmaxdev
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX (Generation)"
myxlab <- "Treatment"

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  # geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3), y=c(255), label = "*", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S3.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_15.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX (magnitude of maximum deviation from generation-0 barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxdev ~ my$treatment + my$ccmaxdev_t0 + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$mmaxdev ~ my$treatment + my$diff0, weights = my$rmaxdev_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without:
# mymod <- glm(my$mmaxdev ~ my$treatment + my$ccmaxdev, weights = my$rmaxdev); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxdev ~ my$treatment, weights = my$rmaxdev); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxdev), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S13.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_16.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxdev
myr <- my$rmaxdev
myc <- my$treatment

mytitle <- NULL
myylab <- "M-MAX"
myxlab <- "Treatment"

myoutline <-  "grey20"
myfill <-  "grey90"
myfillapha <- 0.35
myptalpha <- 0.35
mylinealpha <- 0.35

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3,6), y=c(0.91,0.765), label = c("***", "**"), size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S4.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_17.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX-RATE (generation of maximum rate of change in barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxrate ~ my$treatment + my$ccmaxrate_t0 + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tmaxrate ~ my$treatment + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tmaxrate ~ my$treatment + my$ccmaxrate, weights = my$rmaxrate); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxrate ~ my$treatment, weights = my$rmaxrate); summary(mymod) # Final model!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxrate), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S14.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_18.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxrate
myr <- my$rmaxrate
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX-RATE"
myxlab <- "Treatment"

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  # geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(6), y=c(257), label = "***", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S5.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_19.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX-RATE (magnitude of maximum rate of change in barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxrate ~ my$treatment + my$ccmaxrate_t0 + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$mmaxrate ~ my$treatment + my$diff0, weights = my$rmaxrate_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$mmaxrate ~ my$treatment + my$ccmaxrate, weights = my$rmaxrate); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxrate ~ my$treatment, weights = my$rmaxrate); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rmaxrate), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S15.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_20.html")

# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxrate
myr <- my$rmaxrate
myc <- my$treatment

mytitle <- NULL
myylab <-"M-MAX-RATE"
myxlab <- "Treatment"


mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(4), y=c(0.0325), label = "*", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S6.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_21.pdf", width = mywidth, height = myheight); p; dev.off()

# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on T-MAX-DIFF (generation of maximum difference in sympatric barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tmaxdiff ~ my$treatment + my$ccmaxdiff_t0 + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod) # drop c as least significant term
mymod <- lm(my$tmaxdiff ~ my$treatment + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod)# # FINAL MODEL!

anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S16.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_22.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tmaxdiff
myr <- my$rmaxdiff_rt0
myc <- my$treatment

mytitle <- NULL
myylab <- "T-MAX-DIFF"
myxlab <- "Treatment"

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S7.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_23.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on M-MAX-DIFF (magnitude of maximum difference in sympatric barcoded strain abundance)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$mmaxdiff ~ my$treatment + my$ccmaxdiff_t0 + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod) # drop c as least significant term
mymod <- lm(my$mmaxdiff ~ my$treatment + my$diff0, weights = my$rmaxdiff_rt0); summary(mymod)# # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S17.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_24.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$mmaxdiff
myr <- my$rmaxdiff_rt0
myc <- my$treatment

mytitle <- NULL
myylab <- "M-MAX-DIFF"
myxlab <- "Treatment"

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(3,6), y=c(0.525), label = "***", size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S8.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_25.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>



Analysis: Assess effects of evolutionary treatment on total change in barcode abundance (summed across six intervals)
```{r}
my <- myevo[order(myevo$bctID),] # placeholder dataframe
# model & diagnostic plots ----------------------------------------------------
# with initial proportions included in the model:
# mymod <- glm(my$tcc ~ my$treatment + my$cctcc_t0 + my$diff0, weights = my$rtcc_rt0); summary(mymod) # drop c as least significant term
# mymod <- glm(my$tcc ~ my$treatment + my$diff0, weights = my$rtcc_rt0); summary(mymod) # diff 0 still not significant...run the model set without it.

# without: 
# mymod <- glm(my$tcc ~ my$treatment + my$cctcc, weights = my$rtcc); summary(mymod) # drop c as least significant term
mymod <- lm(my$tcc ~ my$treatment, weights = my$rtcc); summary(mymod) # FINAL MODEL!
anova(mymod) # test term significance with an lm 
hist(residuals(mymod), breaks = 25)
hist(expand_residuals(mymod, my$rtcc), breaks = 25) # this more accurately represents the distribution of residuals in the model output. -- tails look fine here. 
plot(mymod) # check model fit 
summary(mymod)$r.squared # for R2 value
summary(mymod)$adj.r.squared # for adjusted R2 value
# -----------------------------------------------------------------------------

# model output -----------------------------------------------------------------
# tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Table_S18.html")
tab_model(mymod, digits = 5, digits.p = 8, show.stat = T, wrap.labels = 100, file = "000_Additional_File_26.html")
# -----------------------------------------------------------------------------

# Visualize -------------------------------------------------------------------
myx <- my$treatment
myy <- my$tcc
myr <- my$rtcc
myc <- my$treatment

mytitle <- NULL
myylab <- "Total Change in Abundance"
myxlab <- "Treatment"

mypalette <- setpalette
mytextsize <- 8
myheight <- 3.5
mywidth <- 7
myptsize <- ((((myr/max(myr))*10)*((myheight*mywidth)/(7^2))) - min(((myr/max(myr))*10)*((myheight*mywidth)/(7^2))))+1


p <- ggplot(my, aes(x=myx, y=myy, weight = myr, color = myc)) +
  geom_violin(color = myoutline, fill = myfill, draw_quantiles = NULL, inherit.aes = F, aes( x=myx, y=myy), trim = T) + 
  geom_jitter(width =0.15, height = 0, alpha = myptalpha, size = myptsize) +
  geom_segment(x=5.90, xend=6.10, y = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), yend = weighted.mean(myy[myx == "CMhaploid0.001"], myr[myx == "CMhaploid0.001"]), color = myoutline) +
  geom_segment(x=4.90, xend=5.10, y = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), yend = weighted.mean(myy[myx == "CMdiploid0.004"], myr[myx == "CMdiploid0.004"]), color = myoutline) +
  geom_segment(x=3.90, xend=4.10, y = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), yend = weighted.mean(myy[myx == "CMdiploid0.00025"], myr[myx == "CMdiploid0.00025"]), color = myoutline) +
  geom_segment(x=2.90, xend=3.10, y = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Saltdiploid0.001"], myr[myx == "CM+Saltdiploid0.001"]), color = myoutline) +
  geom_segment(x=1.90, xend=2.10, y = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), yend = weighted.mean(myy[myx == "CM+Ethanoldiploid0.001"], myr[myx == "CM+Ethanoldiploid0.001"]), color = myoutline) +
  geom_segment(x=0.90, xend=1.10, y = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), yend = weighted.mean(myy[myx == "CMdiploid0.001"], myr[myx == "CMdiploid0.001"]), color = myoutline) +
  geom_rug(sides = "b" , position = position_nudge(x=-0.75), alpha = myptalpha)+
  scale_color_manual(values =mypalette) + 
  geom_hline(yintercept = 0, lty = "dotted") + 
  coord_flip() +
  theme_classic()+
  theme(legend.position="none") +
  ggtitle(mytitle) + ylab(myylab) + xlab(myxlab)+
  scale_x_discrete(labels = c("CM \n Diploid \n 0.001", "CM+EtOH \n Diploid \n 0.001", "CM+NaCl \n Diploid \n 0.001", "CM \n Diploid \n 0.00025", "CM \n Diploid \n 0.004", "CM \n Haploid \n 0.001")) +
  theme(axis.title.y = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.title.x = element_text(size = 8, face = "bold", margin = margin(0,0,0,0, "pt")))+
  theme(axis.text.y = element_text(size = 8, angle = 0))+
  theme(axis.text.x = element_text(size = 8, angle = 0))+
  annotate("text", x=c(2,4,6), y=c(0.0275,0.06825,0.026), label = c("*","**","*"), size = 8, fontface = "bold")
p 
# -----------------------------------------------------------------------------

# figure output ---------------------------------------------------------------
# pdf(file = "000_Figure_S9.pdf", width = mywidth, height = myheight); p; dev.off()
pdf(file = "000_Additional_File_27.pdf", width = mywidth, height = myheight); p; dev.off()
# -----------------------------------------------------------------------------
rm(my, mymod, p)
```
<br/><br/>

